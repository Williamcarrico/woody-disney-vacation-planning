<!-- Generated by SpecStory -->

# Advanced Recommendation Engine Development (2025-05-20 21:58:37)

_**User**_

Your task is to create an extremely sophisticated, comperhensive and extremely detailed components/optimizer/RecommendationEngine with immereisve deisgn, sophisticated logic and reasoning. The engine needs to incorparate sophisticated recommendations and engine logic. 

---

_**Assistant**_



---

Okay, I'll create a sophisticated and detailed Recommendation Engine component for your Disney vacation planning app. This will involve setting up the necessary file structure, defining data types, implementing core recommendation logic (with placeholders for advanced backend-driven features), and designing an immersive UI.

Here's the plan:

1.  **Create the folder structure and initial files** for the recommendation engine within `src/components/optimizer/recommendation-engine/`.
2.  **Define TypeScript interfaces** in `types.ts` for users, items (attractions, dining, etc.), and recommendations.
3.  **Develop a custom hook** `use-recommendation-logic.hook.ts` to encapsulate the recommendation algorithms. This will include:
    *   Popularity-based suggestions.
    *   Content-based filtering (e.g., based on user preferences like "thrill rides" or "character dining").
    *   Placeholders and comments for integrating more advanced techniques like collaborative filtering or AI-driven suggestions, which would typically rely on backend services.
    *   Logic for ranking and diversifying recommendations.
4.  **Create a `RecommendationCard` component** (`recommendation-card.tsx`) to display individual recommendations in a visually appealing and informative way.
5.  **Build the main `RecommendationEngine` component** (`recommendation-engine.tsx`) which will:
    *   Utilize the `use-recommendation-logic` hook.
    *   Display a list of `RecommendationCard`s.
    *   Incorporate an immersive design using Tailwind CSS, focusing on a clean, modern, and engaging user experience.
    *   Include UI elements for potential user interactions (e.g., "Add to Itinerary", "Not Interested").
    *   Handle loading states and empty states gracefully.
6.  **Implement `RecommendationFilters`** (`recommendation-filters.tsx`) to allow users to refine the suggestions based on criteria like park, activity type, time of day, etc.
7.  **Add utility functions** (`utils.ts`) and constants (`constants.ts`) as needed.
8.  **Ensure all code adheres to the provided guidelines**, including naming conventions, functional components, and JSDoc comments.

Let's start by defining the types for our recommendation engine.

I will now create the `src/components/optimizer/recommendation-engine/types.ts` file.

---

Model failed to call the tool with correct arguments.

---

It seems there was an issue with the previous step. I'll try creating the `types.ts` file again with the necessary definitions.

---

```diff
- 
+ export type AttractionType =
+   | "thrill"
+   | "family"
+   | "kids"
+   | "show"
+   | "water"
+   | "character-meet"
+   | "parade"
+   | "fireworks"
+ 
+ export type DiningType =
+   | "quick-service"
+   | "table-service"
+   | "fine-dining"
+   | "character-dining"
+   | "bar-lounge"
+   | "snack"
+ 
+ export type PriceRange = "$" | "$$" | "$$$" | "$$$$"
+ 
+ export type ParkId =
+   | "magic-kingdom"
+   | "epcot"
+   | "hollywood-studios"
+   | "animal-kingdom"
+   | "typhoon-lagoon"
+   | "blizzard-beach"
+   | "disney-springs"
+ 
+ export interface UserPreferences {
+   userId: string
+   preferredParks?: ParkId[]
+   preferredAttractionTypes?: AttractionType[]
+   preferredDiningTypes?: DiningType[]
+   avoidedAttractionTypes?: AttractionType[]
+   preferredPriceRanges?: PriceRange[]
+   partySize?: number
+   hasYoungChildren?: boolean
+   favoriteCharacters?: string[]
+   pastVisits?: PastVisit[]
+   preferredIntensity?: "low" | "medium" | "high"
+   mobilityNeeds?: boolean
+   preferredPace?: "relaxed" | "moderate" | "fast"
+ }
+ 
+ export interface PastVisit {
+   itemId: string
+   itemType: "attraction" | "dining" | "show" | "event"
+   rating?: 1 | 2 | 3 | 4 | 5 // 1-5 stars
+   lastVisited?: Date
+ }
+ 
+ export interface ItemBase {
+   id: string
+   name: string
+   description: string
+   parkId: ParkId
+   location?: string // e.g., "Fantasyland", "World Showcase - Italy Pavilion"
+   tags?: string[] // General tags like "indoor", "outdoor", "interactive"
+   imageUrl?: string
+   userRating?: {
+     average: number
+     count: number
+   }
+   officialRating?: string // e.g., "Must-do", "Popular"
+   heightRequirement?: number // in cm
+   accessibilityFeatures?: string[]
+ }
+ 
+ export interface AttractionItem extends ItemBase {
+   type: "attraction"
+   attractionType: AttractionType
+   duration?: number // in minutes
+   thrillLevel?: "low" | "medium" | "high"
+   geniePlusAvailable?: boolean
+   individualLightningLaneAvailable?: boolean
+   expectedWaitTime?: number // current or average, in minutes
+ }
+ 
+ export interface DiningItem extends ItemBase {
+   type: "dining"
+   diningType: DiningType
+   cuisine?: string[]
+   priceRange?: PriceRange
+   reservationsRecommended?: boolean
+   mobileOrderAvailable?: boolean
+   menuUrl?: string
+ }
+ 
+ export interface ShowItem extends ItemBase {
+   type: "show"
+   showType: "stage" | "street-performance" | "fireworks" | "parade"
+   duration?: number // in minutes
+   showTimes?: string[] // e.g., ["10:00 AM", "2:00 PM", "7:30 PM"]
+ }
+ 
+ export interface EventItem extends ItemBase {
+   type: "event"
+   eventType: "special-ticketed" | "festival" | "seasonal"
+   eventDates?: { startDate: Date; endDate: Date }
+   eventTimes?: string[]
+ }
+ 
+ export type RecommendableItem = AttractionItem | DiningItem | ShowItem | EventItem
+ 
+ export interface Recommendation {
+   item: RecommendableItem
+   score: number // 0-1, indicating relevance
+   reasoning: string[] // Why this is recommended, e.g., "Matches your preference for thrill rides"
+   source:
+     | "popularity"
+     | "content-based"
+     | "collaborative-filtering"
+     | "contextual"
+     | "user-history"
+     | "hidden-gem"
+   priority?: number // For tie-breaking or boosting certain recommendations
+ }
+ 
+ export interface RecommendationEngineProps {
+   userPreferences: UserPreferences
+   allItems: RecommendableItem[] // This would ideally come from a context or API
+   currentContext?: {
+     timeOfDay?: "morning" | "afternoon" | "evening" | "night"
+     currentPark?: ParkId
+     weather?: "sunny" | "cloudy" | "rainy"
+   }
+   maxRecommendations?: number
+ }
+ 
+ export interface RecommendationFilters {
+   parkId?: ParkId | "all"
+   itemType?: "attraction" | "dining" | "show" | "event" | "all"
+   attractionType?: AttractionType | "all"
+   diningType?: DiningType | "all"
+   priceRange?: PriceRange | "all"
+   sortBy?: "relevance" | "popularity" | "rating"
+   showOnlyAvailableGeniePlus?: boolean
+   showOnlyAvailableLightningLane?: boolean
+   maxWaitTime?: number // in minutes
+ }
```

---

Now that the types are defined, I'll create the `constants.ts` file. This will hold static data like default filter values or weights for different recommendation criteria.

---

```diff
- 
+ import { RecommendationFilters, ParkId, AttractionType, DiningType, PriceRange } from "./types"
+ 
+ export const DEFAULT_RECOMMENDATION_FILTERS: RecommendationFilters = {
+   parkId: "all",
+   itemType: "all",
+   attractionType: "all",
+   diningType: "all",
+   priceRange: "all",
+   sortBy: "relevance",
+   showOnlyAvailableGeniePlus: false,
+   showOnlyAvailableLightningLane: false,
+   maxWaitTime: 120,
+ }
+ 
+ export const PARK_OPTIONS: { value: ParkId | "all"; label: string }[] = [
+   { value: "all", label: "All Parks" },
+   { value: "magic-kingdom", label: "Magic Kingdom" },
+   { value: "epcot", label: "Epcot" },
+   { value: "hollywood-studios", label: "Hollywood Studios" },
+   { value: "animal-kingdom", label: "Animal Kingdom" },
+   { value: "typhoon-lagoon", label: "Typhoon Lagoon" },
+   { value: "blizzard-beach", label: "Blizzard Beach" },
+   { value: "disney-springs", label: "Disney Springs" },
+ ]
+ 
+ export const ITEM_TYPE_OPTIONS: {
+   value: "attraction" | "dining" | "show" | "event" | "all"
+   label: string
+ }[] = [
+   { value: "all", label: "All Types" },
+   { value: "attraction", label: "Attractions" },
+   { value: "dining", label: "Dining" },
+   { value: "show", label: "Shows" },
+   { value: "event", label: "Events" },
+ ]
+ 
+ export const ATTRACTION_TYPE_OPTIONS: { value: AttractionType | "all"; label: string }[] = [
+   { value: "all", label: "All Attraction Types" },
+   { value: "thrill", label: "Thrill Rides" },
+   { value: "family", label: "Family Friendly" },
+   { value: "kids", label: "For Kids" },
+   { value: "show", label: "Shows & Entertainment" }, // Note: 'show' here is an attraction type (e.g. indoor show)
+   { value: "water", label: "Water Rides" },
+   { value: "character-meet", label: "Character Meet & Greets" },
+   { value: "parade", label: "Parades" }, // Attraction representing parade viewing spots/info
+   { value: "fireworks", label: "Fireworks" }, // Attraction representing fireworks viewing spots/info
+ ]
+ 
+ export const DINING_TYPE_OPTIONS: { value: DiningType | "all"; label: string }[] = [
+   { value: "all", label: "All Dining Types" },
+   { value: "quick-service", label: "Quick Service" },
+   { value: "table-service", label: "Table Service" },
+   { value: "fine-dining", label: "Fine/Signature Dining" },
+   { value: "character-dining", label: "Character Dining" },
+   { value: "bar-lounge", label: "Bars & Lounges" },
+   { value: "snack", label: "Snacks & Carts" },
+ ]
+ 
+ export const PRICE_RANGE_OPTIONS: { value: PriceRange | "all"; label: string }[] = [
+   { value: "all", label: "All Price Ranges" },
+   { value: "$", label: "$ (Under $14.99)" },
+   { value: "$$", label: "$$ ($15 - $34.99)" },
+   { value: "$$$", label: "$$$ ($35 - $59.99)" },
+   { value: "$$$$", label: "$$$$ ($60 and up)" },
+ ]
+ 
+ export const SORT_BY_OPTIONS: {
+   value: "relevance" | "popularity" | "rating"
+   label: string
+ }[] = [
+   { value: "relevance", label: "Sort by Relevance" },
+   { value: "popularity", label: "Sort by Popularity" },
+   { value: "rating", label: "Sort by User Rating" },
+ ]
+ 
+ // Weights for scoring - these would be fine-tuned
+ export const SCORING_WEIGHTS = {
+   POPULARITY: 0.2,
+   USER_RATING: 0.3,
+   PREFERENCE_MATCH: 0.5, // Higher weight for direct preference matches
+   PARK_MATCH: 0.1,
+   CONTEXT_TIME_MATCH: 0.15, // e.g., fireworks at night
+   AVOIDANCE_PENALTY: -0.8, // Strong penalty for avoided types
+   PAST_POSITIVE_INTERACTION: 0.25,
+   PAST_NEGATIVE_INTERACTION: -0.4,
+   THRILL_LEVEL_MATCH: 0.1,
+   PRICE_RANGE_MATCH: 0.1,
+   CHARACTER_MATCH: 0.2,
+   RECENCY_BOOST: 0.05, // Boost for newer items or recently updated info
+   DIVERSITY_PENALTY_FACTOR: 0.05, // To penalize recommending too many similar items
+   HIDDEN_GEM_BOOST: 0.1, // For less popular but highly-rated items
+ }
+ 
+ export const MAX_RECOMMENDATIONS_DEFAULT = 10
+ 
+ export const POPULARITY_THRESHOLD = 1000 // e.g., min number of ratings/views to be considered popular
+ export const HIGH_RATING_THRESHOLD = 4.0 // e.g., average rating above this is considered high
```

---

Next, I'll create some utility functions in `utils.ts`. These will include helpers for things like normalizing scores, or perhaps formatting text.

---



---

Next, I'll create some utility functions in `utils.ts`. These will include helpers for things like normalizing scores, or perhaps formatting text.

---



---

Next, I'll create some utility functions in `utils.ts`. These will include helpers for things like normalizing scores, or perhaps formatting text.

---

```diff
- 
+ import { RecommendableItem, Recommendation, ParkId, AttractionItem, DiningItem, ShowItem, EventItem, PriceRange, AttractionType, DiningType } from "./types"
+ 
+ /**
+  * Generates a more descriptive reason string based on recommendation properties.
+  * @param {Recommendation} recommendation - The recommendation object.
+  * @returns {string} A descriptive reason for the recommendation.
+  */
+ export function getDescriptiveReason(recommendation: Recommendation): string {
+   if (recommendation.reasoning && recommendation.reasoning.length > 0) {
+     return recommendation.reasoning.join(". ")
+   }
+ 
+   let reason = `A good option in ${getParkName(recommendation.item.parkId)}.`
+ 
+   if (recommendation.source === "popularity") {
+     reason = `Popular choice at ${getParkName(recommendation.item.parkId)}.`
+   } else if (recommendation.source === "user-history" && recommendation.item.userRating && recommendation.item.userRating.average >= 4) {
+     reason = `You previously enjoyed similar items. This one is highly rated!`
+   }
+ 
+   if (recommendation.item.type === "attraction") {
+     const attraction = recommendation.item as AttractionItem
+     if (attraction.attractionType === "thrill") reason += " Get ready for some thrills!"
+     if (attraction.expectedWaitTime && attraction.expectedWaitTime <= 30) reason += ` Low wait time reported.`
+   }
+   return reason
+ }
+ 
+ /**
+  * Gets the display name for a ParkId.
+  * @param {ParkId} parkId - The park identifier.
+  * @returns {string} The human-readable park name.
+  */
+ export function getParkName(parkId: ParkId): string {
+   const parkNames: Record<ParkId, string> = {
+     "magic-kingdom": "Magic Kingdom",
+     "epcot": "Epcot",
+     "hollywood-studios": "Hollywood Studios",
+     "animal-kingdom": "Animal Kingdom",
+     "typhoon-lagoon": "Typhoon Lagoon",
+     "blizzard-beach": "Blizzard Beach",
+     "disney-springs": "Disney Springs",
+   }
+   return parkNames[parkId] || "Unknown Park"
+ }
+ 
+ /**
+  * Normalizes a score to be within a 0-1 range, if it isn't already.
+  * This is a placeholder, as real normalization might depend on min/max possible scores.
+  * @param {number} score - The raw score.
+  * @param {number} minScore - The minimum possible score in the original scale.
+  * @param {number} maxScore - The maximum possible score in the original scale.
+  * @returns {number} The normalized score (0-1).
+  */
+ export function normalizeScore(score: number, minScore = 0, maxScore = 1): number {
+   if (maxScore === minScore) return 0.5 // Avoid division by zero, return a neutral score
+   const boundedScore = Math.max(minScore, Math.min(score, maxScore))
+   return (boundedScore - minScore) / (maxScore - minScore)
+ }
+ 
+ /**
+  * Formats a duration from minutes to a more readable string.
+  * @param {number} durationInMinutes - The duration in minutes.
+  * @returns {string} Formatted duration string (e.g., "1h 30m", "45m").
+  */
+ export function formatDuration(durationInMinutes?: number): string {
+   if (typeof durationInMinutes !== "number" || durationInMinutes <= 0) return ""
+   const hours = Math.floor(durationInMinutes / 60)
+   const minutes = durationInMinutes % 60
+   let formatted = ""
+   if (hours > 0) formatted += `${hours}h `
+   if (minutes > 0) formatted += `${minutes}m`
+   return formatted.trim()
+ }
+ 
+ /**
+  * Gets a placeholder image URL if the item's imageUrl is missing.
+  * @param {RecommendableItem} item - The recommendable item.
+  * @returns {string} The item's image URL or a default placeholder.
+  */
+ export function getItemImageUrl(item: RecommendableItem): string {
+   return item.imageUrl || "/images/placeholder-disney.jpg" // Ensure you have this placeholder image
+ }
+ 
+ /**
+  * Converts a PriceRange to a more descriptive string.
+  * @param {PriceRange} priceRange - The price range symbol.
+  * @returns {string} A descriptive string for the price range.
+  */
+ export function getPriceRangeDescription(priceRange?: PriceRange): string {
+   if (!priceRange) return "Price not available"
+   switch (priceRange) {
+     case "$":
+       return "Under $14.99 per adult"
+     case "$$":
+       return "$15 to $34.99 per adult"
+     case "$$$":
+       return "$35 to $59.99 per adult"
+     case "$$$$":
+       return "$60 and up per adult"
+     default:
+       return "Price not specified"
+   }
+ }
+ 
+ /**
+  * Provides a human-readable label for attraction types.
+  * @param {AttractionType} type - The attraction type.
+  * @returns {string} Human-readable label.
+  */
+ export function getAttractionTypeLabel(type: AttractionType): string {
+     const labels: Record<AttractionType, string> = {
+         "thrill": "Thrill Ride",
+         "family": "Family Friendly",
+         "kids": "Kid-Friendly",
+         "show": "Show / Entertainment",
+         "water": "Water Ride",
+         "character-meet": "Character Meet & Greet",
+         "parade": "Parade",
+         "fireworks": "Fireworks Spectacular"
+     };
+     return labels[type] || type;
+ }
+ 
+ /**
+  * Provides a human-readable label for dining types.
+  * @param {DiningType} type - The dining type.
+  * @returns {string} Human-readable label.
+  */
+ export function getDiningTypeLabel(type: DiningType): string {
+     const labels: Record<DiningType, string> = {
+         "quick-service": "Quick Service",
+         "table-service": "Table Service",
+         "fine-dining": "Fine/Signature Dining",
+         "character-dining": "Character Dining",
+         "bar-lounge": "Bar/Lounge",
+         "snack": "Snack Location"
+     };
+     return labels[type] || type;
+ }
+ 
+ /**
+  * A simple debounce function.
+  */
+ export function debounce<F extends (...args: any[]) => any>(func: F, waitFor: number) {
+   let timeout: NodeJS.Timeout
+ 
+   return (...args: Parameters<F>): Promise<ReturnType<F>> =>
+     new Promise(resolve => {
+       if (timeout) {
+         clearTimeout(timeout)
+       }
+ 
+       timeout = setTimeout(() => resolve(func(...args)), waitFor)
+     })
+ } 
```

---

Now, I'll create the `index.ts` file for the `recommendation-engine` directory, which will export the main components.

---

```diff
- 
+ export * from "./recommendation-engine"
+ export * from "./types"
```

---

With the foundational files in place, I will now create the core logic for the recommendation engine in a custom hook: `src/components/optimizer/recommendation-engine/use-recommendation-logic.hook.ts`.

This hook will contain functions for:
*   Scoring items based on user preferences, context, and item characteristics.
*   Applying various recommendation strategies (popularity, content-based, contextual).
*   Filtering and ranking the recommendations.
*   Placeholders/comments for where more advanced backend logic (like collaborative filtering or ML models) would integrate.

---

```diff
- 
+ "use client"
+ 
+ import { useState, useEffect, useCallback, useMemo } from "react"
+ import {
+   RecommendableItem,
+   UserPreferences,
+   Recommendation,
+   RecommendationEngineProps,
+   RecommendationFilters,
+   AttractionItem,
+   DiningItem,
+   PastVisit,
+ } from "./types"
+ import {
+   SCORING_WEIGHTS,
+   MAX_RECOMMENDATIONS_DEFAULT,
+   POPULARITY_THRESHOLD,
+   HIGH_RATING_THRESHOLD,
+ } from "./constants"
+ import { normalizeScore } from "./utils"
+ 
+ /**
+  * @hook useRecommendationLogic
+  * @description Encapsulates the core logic for generating and filtering recommendations.
+  *
+  * This hook implements several recommendation strategies:
+  * 1. Popularity-based: Recommends items that are generally popular.
+  * 2. Content-based: Matches items to explicit user preferences (e.g., preferred parks, attraction types).
+  * 3. Contextual: Considers current context like time of day or current park (basic implementation).
+  * 4. User History: Boosts items similar to positively-rated past visits and penalizes negatively-rated ones.
+  * 5. Hidden Gems: Attempts to boost high-quality but less popular items.
+  *
+  * It also includes placeholders and comments for integrating more advanced
+  * backend-driven features like collaborative filtering or AI-driven suggestions.
+  */
+ export function useRecommendationLogic({
+   userPreferences,
+   allItems,
+   currentContext,
+   maxRecommendations = MAX_RECOMMENDATIONS_DEFAULT,
+ }: RecommendationEngineProps) {
+   const [recommendations, setRecommendations] = useState<Recommendation[]>([])
+   const [isLoading, setIsLoading] = useState<boolean>(true)
+   const [error, setError] = useState<string | null>(null)
+ 
+   const scoreItem = useCallback(
+     (item: RecommendableItem): Recommendation | null => {
+       let score = 0
+       const reasoning: string[] = []
+ 
+       // 1. Popularity Score (Base)
+       if (item.userRating && item.userRating.count > 0) {
+         const popularityScore = normalizeScore(item.userRating.count, 0, POPULARITY_THRESHOLD * 2) // Max count can be higher than threshold
+         score += popularityScore * SCORING_WEIGHTS.POPULARITY
+         if (item.userRating.count > POPULARITY_THRESHOLD) reasoning.push("Popular item")
+       }
+ 
+       // 2. User Rating Score
+       if (item.userRating && item.userRating.average > 0) {
+         const ratingScore = normalizeScore(item.userRating.average, 1, 5)
+         score += ratingScore * SCORING_WEIGHTS.USER_RATING
+         if (item.userRating.average >= HIGH_RATING_THRESHOLD) reasoning.push("Highly rated by users")
+       }
+ 
+       // 3. Content-Based Filtering (User Preferences)
+       if (userPreferences.preferredParks?.includes(item.parkId)) {
+         score += SCORING_WEIGHTS.PARK_MATCH
+         reasoning.push(`Located in a preferred park: ${item.parkId}`)
+       }
+ 
+       if (item.type === "attraction") {
+         const attraction = item as AttractionItem
+         if (userPreferences.preferredAttractionTypes?.includes(attraction.attractionType)) {
+           score += SCORING_WEIGHTS.PREFERENCE_MATCH
+           reasoning.push(`Matches preferred attraction type: ${attraction.attractionType}`)
+         }
+         if (userPreferences.avoidedAttractionTypes?.includes(attraction.attractionType)) {
+           score += SCORING_WEIGHTS.AVOIDANCE_PENALTY
+           reasoning.push(`Matches an avoided attraction type: ${attraction.attractionType}`)
+         }
+         if (userPreferences.preferredIntensity && attraction.thrillLevel === userPreferences.preferredIntensity) {
+           score += SCORING_WEIGHTS.THRILL_LEVEL_MATCH
+           reasoning.push(`Matches preferred intensity: ${attraction.thrillLevel}`)
+         }
+       } else if (item.type === "dining") {
+         const dining = item as DiningItem
+         if (userPreferences.preferredDiningTypes?.includes(dining.diningType)) {
+           score += SCORING_WEIGHTS.PREFERENCE_MATCH
+           reasoning.push(`Matches preferred dining type: ${dining.diningType}`)
+         }
+         if (userPreferences.preferredPriceRanges?.includes(dining.priceRange!)) {
+           score += SCORING_WEIGHTS.PRICE_RANGE_MATCH
+           reasoning.push(`Matches preferred price range: ${dining.priceRange}`)
+         }
+       }
+ 
+       // 4. User History
+       userPreferences.pastVisits?.forEach((visit: PastVisit) => {
+         if (visit.itemId === item.id) {
+           if (visit.rating && visit.rating >= 4) {
+             score += SCORING_WEIGHTS.PAST_POSITIVE_INTERACTION
+             reasoning.push("You previously enjoyed this.")
+           } else if (visit.rating && visit.rating <= 2) {
+             score += SCORING_WEIGHTS.PAST_NEGATIVE_INTERACTION
+             reasoning.push("You previously rated this low.")
+           }
+         }
+         // TODO: Add logic for similarity to past visits (requires item similarity metric)
+         // e.g., if item is similar to a highly-rated past visit, boost score.
+       })
+ 
+       // 5. Contextual Factors (Basic)
+       if (currentContext?.currentPark && item.parkId === currentContext.currentPark) {
+         score += SCORING_WEIGHTS.PARK_MATCH * 1.5 // Boost if in current park
+         reasoning.push("Located in your current park!")
+       }
+       if (currentContext?.timeOfDay) {
+         // Example: Boost fireworks at night
+         if (item.type === "show" && (item as any).showType === "fireworks" && (currentContext.timeOfDay === "evening" || currentContext.timeOfDay === "night")) {
+           score += SCORING_WEIGHTS.CONTEXT_TIME_MATCH
+           reasoning.push("Perfect for this time of day!")
+         }
+         // Example: Boost indoor activities if rainy
+         if (currentContext.weather === "rainy" && item.tags?.includes("indoor")) {
+             score += SCORING_WEIGHTS.CONTEXT_TIME_MATCH * 0.5;
+             reasoning.push("Good choice for rainy weather.");
+         }
+       }
+ 
+       // 6. Favorite Characters (Basic)
+       if (userPreferences.favoriteCharacters && userPreferences.favoriteCharacters.length > 0) {
+         const characterMatch = userPreferences.favoriteCharacters.some(char =>
+           item.name.toLowerCase().includes(char.toLowerCase()) ||
+           item.description.toLowerCase().includes(char.toLowerCase()) ||
+           item.tags?.some(tag => tag.toLowerCase().includes(char.toLowerCase()))
+         )
+         if (characterMatch) {
+           score += SCORING_WEIGHTS.CHARACTER_MATCH
+           reasoning.push("Features one of your favorite characters!")
+         }
+       }
+ 
+       // 7. Hidden Gem Boost
+       if (item.userRating && item.userRating.average >= HIGH_RATING_THRESHOLD && item.userRating.count < POPULARITY_THRESHOLD) {
+         score += SCORING_WEIGHTS.HIDDEN_GEM_BOOST
+         reasoning.push("Highly-rated hidden gem!")
+       }
+ 
+       // Ensure score is not negative unless due to strong avoidance
+       if (score < 0 && SCORING_WEIGHTS.AVOIDANCE_PENALTY === 0) score = 0.01 // Small positive if no hard avoidance
+       else if (score < 0 && reasoning.some(r => r.includes("avoided"))) {
+          // Allow negative score if it's due to avoidance
+       } else if (score < 0) {
+         score = 0.01
+       }
+ 
+       // TODO: More sophisticated scoring based on collaborative filtering (backend integration)
+       // e.g., fetch collaborative scores for items based on similar user behavior.
+ 
+       // TODO: AI-driven scoring (backend integration)
+       // e.g., use an ML model to predict user preference score.
+ 
+       if (score <= 0 && !reasoning.some(r => r.includes("avoided"))) return null // Don't recommend if score is too low and not an avoided item.
+ 
+       return {
+         item,
+         score: normalizeScore(score, -1, 3), // Normalize: score can range, e.g. -1 (avoid) to ~3 (many boosts)
+         reasoning: Array.from(new Set(reasoning)), // Unique reasons
+         source: "content-based", // This would be dynamic with more sources
+       }
+     },
+     [userPreferences, currentContext] // allItems is not a dependency here as it's processed once
+   )
+ 
+   const generateRecommendations = useCallback(() => {
+     setIsLoading(true)
+     setError(null)
+ 
+     try {
+       // Simulate API call delay
+       setTimeout(() => {
+         let scoredItems = allItems
+           .map(item => scoreItem(item))
+           .filter(Boolean) as Recommendation[]
+ 
+         // Apply Diversity Penalty (simple version)
+         // This is a naive implementation. True diversity requires more complex logic.
+         const finalRecommendations: Recommendation[] = []
+         const typeCounts: Record<string, number> = {}
+ 
+         scoredItems.sort((a, b) => (b.priority || 0) - (a.priority || 0) || b.score - a.score)
+ 
+         for (const rec of scoredItems) {
+           if (finalRecommendations.length >= maxRecommendations) break
+ 
+           const itemTypeKey = rec.item.type === "attraction" ? (rec.item as AttractionItem).attractionType : rec.item.type
+           typeCounts[itemTypeKey] = (typeCounts[itemTypeKey] || 0) + 1
+ 
+           let diversityPenalty = 0
+           if (typeCounts[itemTypeKey] > 2) { // Penalize after 2 items of the same specific type
+             diversityPenalty = (typeCounts[itemTypeKey] - 2) * SCORING_WEIGHTS.DIVERSITY_PENALTY_FACTOR
+           }
+ 
+           const finalScore = rec.score - diversityPenalty
+ 
+           if (finalScore > 0.1 || rec.reasoning.some(r => r.includes("avoided"))) { // Threshold to include, or if it's an explicitly avoided item (to show *why* it's not recommended if we choose to show such)
+             finalRecommendations.push({ ...rec, score: Math.max(0, finalScore) })
+           }
+         }
+ 
+         // Sort again after diversity penalty
+         finalRecommendations.sort((a,b) => b.score - a.score);
+ 
+         setRecommendations(finalRecommendations.slice(0, maxRecommendations))
+         setIsLoading(false)
+       }, 500)
+     } catch (e) {
+       console.error("Error generating recommendations:", e)
+       setError("Could not generate recommendations at this time.")
+       setIsLoading(false)
+     }
+   }, [allItems, scoreItem, maxRecommendations])
+ 
+   useEffect(() => {
+     if (allItems && allItems.length > 0 && userPreferences) {
+       generateRecommendations()
+     }
+   }, [allItems, userPreferences, generateRecommendations])
+ 
+   const applyFilters = useCallback(
+     (filters: RecommendationFilters, currentRecs: Recommendation[]): Recommendation[] => {
+       let filtered = [...currentRecs]
+ 
+       if (filters.parkId && filters.parkId !== "all") {
+         filtered = filtered.filter(r => r.item.parkId === filters.parkId)
+       }
+ 
+       if (filters.itemType && filters.itemType !== "all") {
+         filtered = filtered.filter(r => r.item.type === filters.itemType)
+       }
+ 
+       if (item.type === "attraction" && filters.attractionType && filters.attractionType !== "all") {
+         filtered = filtered.filter(r => r.item.type === "attraction" && (r.item as AttractionItem).attractionType === filters.attractionType)
+       }
+ 
+       if (item.type === "dining" && filters.diningType && filters.diningType !== "all") {
+         filtered = filtered.filter(r => r.item.type === "dining" && (r.item as DiningItem).diningType === filters.diningType)
+       }
+ 
+       if (filters.priceRange && filters.priceRange !== "all") {
+         filtered = filtered.filter(r => r.item.type === "dining" && (r.item as DiningItem).priceRange === filters.priceRange)
+       }
+ 
+       if (filters.showOnlyAvailableGeniePlus) {
+         filtered = filtered.filter(r => r.item.type === "attraction" && (r.item as AttractionItem).geniePlusAvailable)
+       }
+ 
+       if (filters.showOnlyAvailableLightningLane) {
+         filtered = filtered.filter(r => r.item.type === "attraction" && (r.item as AttractionItem).individualLightningLaneAvailable)
+       }
+ 
+       if (filters.maxWaitTime) {
+         filtered = filtered.filter(r => {
+           if (r.item.type === "attraction") {
+             const attraction = r.item as AttractionItem
+             return attraction.expectedWaitTime === undefined || attraction.expectedWaitTime <= filters.maxWaitTime!
+           }
+           return true
+         })
+       }
+ 
+       if (filters.sortBy) {
+         switch (filters.sortBy) {
+           case "popularity":
+             filtered.sort((a, b) => (b.item.userRating?.count || 0) - (a.item.userRating?.count || 0))
+             break
+           case "rating":
+             filtered.sort((a, b) => (b.item.userRating?.average || 0) - (a.item.userRating?.average || 0))
+             break
+           case "relevance": // Default sort is already by score (relevance)
+           default:
+             filtered.sort((a, b) => b.score - a.score)
+             break
+         }
+       }
+       return filtered.slice(0, maxRecommendations)
+     },
+     [maxRecommendations]
+   )
+ 
+   const updateRecommendationsWithFilters = useCallback(
+     (filters: RecommendationFilters) => {
+       // Re-generate initial recommendations if not already done or if crucial inputs change.
+       // For now, we assume initial generation is done and we filter the existing set.
+       // A more robust solution might re-score or fetch new server-side recs based on filters.
+       setIsLoading(true);
+       // Simulate filtering delay
+       setTimeout(() => {
+         const newFilteredRecs = applyFilters(filters, recommendations); // Apply to the current full set of recommendations
+         setRecommendations(newFilteredRecs);
+         setIsLoading(false);
+       }, 300);
+     },
+     [applyFilters, recommendations] // recommendations is a dependency here
+   );
+ 
+ 
+   return { recommendations, isLoading, error, generateRecommendations, applyFilters: updateRecommendationsWithFilters }
+ }
```

---

There appears to be a small syntax error in the generated `use-recommendation-logic.hook.ts` file related to `item.type` within the `applyFilters` function. I will correct this.

---

```diff
              }
  
-             if (item.type === "attraction" && filters.attractionType && filters.attractionType !== "all") {
+             if (filters.attractionType && filters.attractionType !== "all") {
                  filtered = filtered.filter(r => r.item.type === "attraction" && (r.item as AttractionItem).attractionType === filters.attractionType)
              }
  
-             if (item.type === "dining" && filters.diningType && filters.diningType !== "all") {
+             if (filters.diningType && filters.diningType !== "all") {
                  filtered = filtered.filter(r => r.item.type === "dining" && (r.item as DiningItem).diningType === filters.diningType)
              }
```

---

The previous correction wasn't quite right. The `applyFilters` function in `use-recommendation-logic.hook.ts` still needs adjustment for the `attractionType` and `diningType` filters. I'll fix those conditions.

---

```diff
  
              if (filters.attractionType && filters.attractionType !== "all") {
-                 filtered = filtered.filter(r => r.item.type === "attraction" && (r.item as AttractionItem).attractionType === filters.attractionType)
+                 filtered = filtered.filter(r =>
+                     r.item.type === "attraction" &&
+                     (r.item as AttractionItem).attractionType === filters.attractionType
+                 )
              }
  
              if (filters.diningType && filters.diningType !== "all") {
-                 filtered = filtered.filter(r => r.item.type === "dining" && (r.item as DiningItem).diningType === filters.diningType)
+                 filtered = filtered.filter(r =>
+                     r.item.type === "dining" &&
+                     (r.item as DiningItem).diningType === filters.diningType
+                 )
              }
  
```

---

Now I will create the `RecommendationCard.tsx` component. This component will be responsible for displaying a single recommendation item with an engaging and informative design. It will show the item's image, name, key details (like park, type, rating), and the reason it's being recommended.

---

```diff
- 
+ "use client"
+ 
+ import React from "react"
+ import Image from "next/image"
+ import { Button } from "@/components/ui/button"
+ import { Badge } from "@/components/ui/badge"
+ import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
+ import { Star, Zap, MapPin, Info, PlusCircle, Ban } from "lucide-react"
+ import {
+   Recommendation,
+   AttractionItem,
+   DiningItem,
+   ShowItem,
+   EventItem,
+ } from "./types"
+ import {
+   getParkName,
+   formatDuration,
+   getItemImageUrl,
+   getDescriptiveReason,
+   getPriceRangeDescription,
+   getAttractionTypeLabel,
+   getDiningTypeLabel
+ } from "./utils"
+ 
+ interface RecommendationCardProps {
+   recommendation: Recommendation
+   onAddToItinerary?: (item: RecommendableItem) => void
+   onNotInterested?: (itemId: string) => void
+   isLoading?: boolean
+ }
+ 
+ /**
+  * @component RecommendationCard
+  * @description Displays a single recommendation item with an immersive and informative design.
+  * It includes item details, image, reasoning, and action buttons.
+  */
+ export function RecommendationCard({
+   recommendation,
+   onAddToItinerary,
+   onNotInterested,
+   isLoading = false,
+ }: RecommendationCardProps) {
+   const { item, score, reasoning, source } = recommendation
+ 
+   if (isLoading) {
+     return <RecommendationCardSkeleton />
+   }
+ 
+   const descriptiveReason = getDescriptiveReason(recommendation)
+ 
+   const renderItemSpecificDetails = () => {
+     switch (item.type) {
+       case "attraction":
+         const attraction = item as AttractionItem
+         return (
+           <>
+             <Badge variant="outline" className="text-xs">
+               {getAttractionTypeLabel(attraction.attractionType)}
+             </Badge>
+             {attraction.thrillLevel && <Badge variant="secondary" className="text-xs">{attraction.thrillLevel} thrill</Badge>}
+             {attraction.expectedWaitTime !== undefined && (
+               <Badge variant={attraction.expectedWaitTime <= 30 ? "success" : "warning"} className="text-xs">
+                 {attraction.expectedWaitTime} min wait
+               </Badge>
+             )}
+             {formatDuration(attraction.duration) && <Badge variant="outline" className="text-xs">{formatDuration(attraction.duration)}</Badge>}
+             {attraction.geniePlusAvailable && <Badge variant="info" className="text-xs">Genie+</Badge>}
+             {attraction.individualLightningLaneAvailable && <Badge variant="info" className="text-xs">ILL</Badge>}
+           </>
+         )
+       case "dining":
+         const dining = item as DiningItem
+         return (
+           <>
+             <Badge variant="outline" className="text-xs">{getDiningTypeLabel(dining.diningType)}</Badge>
+             {dining.priceRange && <Badge variant="secondary" className="text-xs">{getPriceRangeDescription(dining.priceRange)}</Badge>}
+             {dining.cuisine?.map(c => <Badge key={c} variant="outline" className="text-xs">{c}</Badge>)}
+             {dining.reservationsRecommended && <Badge variant="warning" className="text-xs">Reservations Recommended</Badge>}
+           </>
+         )
+       case "show":
+         const show = item as ShowItem
+         return (
+           <>
+             <Badge variant="outline" className="text-xs">{show.showType}</Badge>
+             {formatDuration(show.duration) && <Badge variant="secondary" className="text-xs">{formatDuration(show.duration)}</Badge>}
+             {show.showTimes && show.showTimes.length > 0 && <Badge variant="outline" className="text-xs">{show.showTimes.slice(0, 2).join(", ")}</Badge>}
+           </>
+         )
+       case "event":
+         const event = item as EventItem
+         return (
+           <>
+             <Badge variant="outline" className="text-xs">{event.eventType} Event</Badge>
+             {event.eventDates && <Badge variant="secondary" className="text-xs">{new Date(event.eventDates.startDate).toLocaleDateString()} - {new Date(event.eventDates.endDate).toLocaleDateString()}</Badge>}
+           </>
+         )
+       default:
+         return null
+     }
+   }
+ 
+   return (
+     <Card className="overflow-hidden shadow-lg hover:shadow-xl transition-shadow duration-300 ease-in-out bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white border-purple-700">
+       <CardHeader className="p-0 relative">
+         <div className="w-full h-48 relative">
+           <Image
+             src={getItemImageUrl(item)}
+             alt={item.name}
+             layout="fill"
+             objectFit="cover"
+             className="transition-transform duration-300 ease-in-out group-hover:scale-105"
+           />
+           <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-black/40 to-transparent" />
+           <div className="absolute bottom-0 left-0 p-4">
+             <CardTitle className="text-lg font-bold text-shadow-md">{item.name}</CardTitle>
+             <div className="flex items-center text-xs text-amber-400 mt-1">
+               <MapPin size={14} className="mr-1" />
+               {getParkName(item.parkId)} {item.location && `- ${item.location}`}
+             </div>
+           </div>
+         </div>
+         <Badge className="absolute top-2 right-2 text-xs bg-amber-500 text-black" variant="default">
+           Score: {score.toFixed(2)}
+         </Badge>
+       </CardHeader>
+       <CardContent className="p-4 space-y-3">
+         <div className="flex flex-wrap gap-2 text-xs">
+           {renderItemSpecificDetails()}
+         </div>
+         <p className="text-xs text-purple-300 italic flex items-start">
+           <Info size={16} className="mr-2 flex-shrink-0 mt-0.5" />
+           <span>{descriptiveReason}</span>
+         </p>
+         {reasoning.length > 0 && source !== "popularity" && (
+             <details className="text-xs text-slate-400">
+                 <summary className="cursor-pointer hover:text-slate-300">More details...</summary>
+                 <ul className="list-disc pl-5 mt-1 space-y-1">
+                     {recommendation.reasoning.map((r, i) => <li key={i}>{r}</li>)}
+                 </ul>
+             </details>
+         )}
+       </CardContent>
+       <CardFooter className="p-4 flex justify-between items-center bg-black/30">
+         <div className="flex items-center text-xs">
+           {item.userRating && (
+             <>
+               <Star size={16} className="mr-1 text-yellow-400" />
+               <span>{item.userRating.average.toFixed(1)} ({item.userRating.count} ratings)</span>
+             </>
+           )}
+         </div>
+         <div className="flex gap-2">
+           {onAddToItinerary && (
+             <Button variant="success" size="sm" onClick={() => onAddToItinerary(item)} className="group">
+               <PlusCircle size={16} className="mr-2 transition-transform duration-300 group-hover:rotate-90" /> Add
+             </Button>
+           )}
+           {onNotInterested && (
+             <Button variant="destructive_outline" size="sm" onClick={() => onNotInterested(item.id)} className="group">
+               <Ban size={16} className="mr-2 transition-transform duration-300 group-hover:scale-125" /> Hide
+             </Button>
+           )}
+         </div>
+       </CardFooter>
+     </Card>
+   )
+ }
+ 
+ /**
+  * @component RecommendationCardSkeleton
+  * @description Displays a skeleton loader for the RecommendationCard.
+  */
+ export function RecommendationCardSkeleton() {
+   return (
+     <Card className="overflow-hidden shadow-lg bg-slate-800 border-slate-700 animate-pulse">
+       <CardHeader className="p-0 relative">
+         <div className="w-full h-48 bg-slate-700" />
+         <div className="absolute bottom-0 left-0 p-4">
+           <div className="h-5 w-3/4 bg-slate-600 rounded mb-1"></div>
+           <div className="h-3 w-1/2 bg-slate-600 rounded"></div>
+         </div>
+         <div className="absolute top-2 right-2 h-5 w-16 bg-slate-600 rounded"></div>
+       </CardHeader>
+       <CardContent className="p-4 space-y-3">
+         <div className="flex flex-wrap gap-2">
+           <div className="h-5 w-20 bg-slate-700 rounded"></div>
+           <div className="h-5 w-24 bg-slate-700 rounded"></div>
+           <div className="h-5 w-16 bg-slate-700 rounded"></div>
+         </div>
+         <div className="h-4 w-full bg-slate-700 rounded mt-1"></div>
+         <div className="h-4 w-3/4 bg-slate-700 rounded"></div>
+       </CardContent>
+       <CardFooter className="p-4 flex justify-between items-center bg-slate-700/50">
+         <div className="flex items-center">
+           <div className="h-5 w-24 bg-slate-600 rounded"></div>
+         </div>
+         <div className="flex gap-2">
+           <div className="h-9 w-20 bg-slate-600 rounded"></div>
+           <div className="h-9 w-20 bg-slate-600 rounded"></div>
+         </div>
+       </CardFooter>
+     </Card>
+   )
+ } 
```

---

Next, I will implement the `RecommendationFilters.tsx` component. This will provide UI elements for users to filter the list of recommendations based on various criteria like park, item type, price range, etc. It will use Shadcn UI components for a consistent look and feel.

---

```diff
- 
+ "use client"
+ 
+ import React, { useState, useEffect } from "react"
+ import { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from "@/components/ui/accordion"
+ import { Button } from "@/components/ui/button"
+ import { Label } from "@/components/ui/label"
+ import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
+ import { Switch } from "@/components/ui/switch"
+ import { Slider } from "@/components/ui/slider"
+ import { Input } from "@/components/ui/input"
+ import { Filter, XCircle } from "lucide-react"
+ import { RecommendationFilters as RecommendationFiltersType, ParkId, AttractionType, DiningType, PriceRange } from "./types"
+ import {
+   PARK_OPTIONS,
+   ITEM_TYPE_OPTIONS,
+   ATTRACTION_TYPE_OPTIONS,
+   DINING_TYPE_OPTIONS,
+   PRICE_RANGE_OPTIONS,
+   SORT_BY_OPTIONS,
+   DEFAULT_RECOMMENDATION_FILTERS,
+ } from "./constants"
+ import { debounce } from "./utils"
+ 
+ interface RecommendationFiltersProps {
+   initialFilters?: RecommendationFiltersType
+   onFiltersChange: (filters: RecommendationFiltersType) => void
+   isLoading?: boolean
+ }
+ 
+ /**
+  * @component RecommendationFilters
+  * @description Provides a UI for users to filter and sort recommendations.
+  * Uses Shadcn UI components for a consistent look and feel.
+  */
+ export function RecommendationFilters({
+   initialFilters = DEFAULT_RECOMMENDATION_FILTERS,
+   onFiltersChange,
+   isLoading = false,
+ }: RecommendationFiltersProps) {
+   const [filters, setFilters] = useState<RecommendationFiltersType>(initialFilters)
+   const [isAccordionOpen, setIsAccordionOpen] = useState(false)
+ 
+   const debouncedOnFiltersChange = React.useCallback(debounce(onFiltersChange, 500), [onFiltersChange]);
+ 
+   useEffect(() => {
+     debouncedOnFiltersChange(filters)
+   }, [filters, debouncedOnFiltersChange])
+ 
+   const handleFilterChange = <K extends keyof RecommendationFiltersType>(
+     key: K,
+     value: RecommendationFiltersType[K]
+   ) => {
+     setFilters(prev => ({ ...prev, [key]: value }))
+   }
+ 
+   const handleResetFilters = () => {
+     setFilters(DEFAULT_RECOMMENDATION_FILTERS)
+     onFiltersChange(DEFAULT_RECOMMENDATION_FILTERS) // Apply immediately
+   }
+ 
+   const toggleAccordion = () => setIsAccordionOpen(!isAccordionOpen)
+ 
+   return (
+     <div className="mb-6 p-4 bg-slate-800/50 border border-slate-700 rounded-lg shadow-md">
+       <Button onClick={toggleAccordion} variant="ghost" className="w-full justify-between text-lg font-semibold text-purple-300 hover:text-purple-200 mb-2">
+         {isAccordionOpen ? "Hide Filters" : "Show Filters & Sort"}
+         <Filter size={20} className={`transition-transform duration-300 ${isAccordionOpen ? 'rotate-180' : ''}`} />
+       </Button>
+       <Accordion type="single" collapsible Wt="[calc(100%-3rem)]" value={isAccordionOpen ? "filtersAccordion" : ""} onValueChange={(value) => setIsAccordionOpen(value === "filtersAccordion")}>
+         <AccordionItem value="filtersAccordion" className="border-none">
+           <AccordionContent className="pt-4">
+             <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
+               {/* Park Filter */}
+               <div className="space-y-2">
+                 <Label htmlFor="parkFilter" className="text-slate-300">Park</Label>
+                 <Select
+                   value={filters.parkId}
+                   onValueChange={(value: ParkId | "all") => handleFilterChange("parkId", value)}
+                   disabled={isLoading}
+                 >
+                   <SelectTrigger id="parkFilter" className="bg-slate-700 border-slate-600 text-white">
+                     <SelectValue placeholder="Select Park" />
+                   </SelectTrigger>
+                   <SelectContent className="bg-slate-700 border-slate-600 text-white">
+                     {PARK_OPTIONS.map(opt => (
+                       <SelectItem key={opt.value} value={opt.value} className="hover:bg-slate-600">{opt.label}</SelectItem>
+                     ))}
+                   </SelectContent>
+                 </Select>
+               </div>
+ 
+               {/* Item Type Filter */}
+               <div className="space-y-2">
+                 <Label htmlFor="itemTypeFilter" className="text-slate-300">Item Type</Label>
+                 <Select
+                   value={filters.itemType}
+                   onValueChange={(value: "attraction" | "dining" | "show" | "event" | "all") => handleFilterChange("itemType", value)}
+                   disabled={isLoading}
+                 >
+                   <SelectTrigger id="itemTypeFilter" className="bg-slate-700 border-slate-600 text-white">
+                     <SelectValue placeholder="Select Item Type" />
+                   </SelectTrigger>
+                   <SelectContent className="bg-slate-700 border-slate-600 text-white">
+                     {ITEM_TYPE_OPTIONS.map(opt => (
+                       <SelectItem key={opt.value} value={opt.value} className="hover:bg-slate-600">{opt.label}</SelectItem>
+                     ))}
+                   </SelectContent>
+                 </Select>
+               </div>
+ 
+               {/* Attraction Type Filter (Conditional) */}
+               {filters.itemType === "attraction" || filters.itemType === "all" ? (
+                 <div className="space-y-2">
+                   <Label htmlFor="attractionTypeFilter" className="text-slate-300">Attraction Type</Label>
+                   <Select
+                     value={filters.attractionType}
+                     onValueChange={(value: AttractionType | "all") => handleFilterChange("attractionType", value)}
+                     disabled={isLoading || filters.itemType === "dining" || filters.itemType === "show" || filters.itemType === "event"}
+                   >
+                     <SelectTrigger id="attractionTypeFilter" className="bg-slate-700 border-slate-600 text-white">
+                       <SelectValue placeholder="Select Attraction Type" />
+                     </SelectTrigger>
+                     <SelectContent className="bg-slate-700 border-slate-600 text-white">
+                       {ATTRACTION_TYPE_OPTIONS.map(opt => (
+                         <SelectItem key={opt.value} value={opt.value} className="hover:bg-slate-600">{opt.label}</SelectItem>
+                       ))}
+                     </SelectContent>
+                   </Select>
+                 </div>
+               ) : null}
+ 
+               {/* Dining Type Filter (Conditional) */}
+               {filters.itemType === "dining" || filters.itemType === "all" ? (
+                 <div className="space-y-2">
+                   <Label htmlFor="diningTypeFilter" className="text-slate-300">Dining Type</Label>
+                   <Select
+                     value={filters.diningType}
+                     onValueChange={(value: DiningType | "all") => handleFilterChange("diningType", value)}
+                     disabled={isLoading || filters.itemType === "attraction" || filters.itemType === "show" || filters.itemType === "event"}
+                   >
+                     <SelectTrigger id="diningTypeFilter" className="bg-slate-700 border-slate-600 text-white">
+                       <SelectValue placeholder="Select Dining Type" />
+                     </SelectTrigger>
+                     <SelectContent className="bg-slate-700 border-slate-600 text-white">
+                       {DINING_TYPE_OPTIONS.map(opt => (
+                         <SelectItem key={opt.value} value={opt.value} className="hover:bg-slate-600">{opt.label}</SelectItem>
+                       ))}
+                     </SelectContent>
+                   </Select>
+                 </div>
+               ) : null}
+ 
+               {/* Price Range Filter (Conditional) */}
+               {filters.itemType === "dining" || filters.itemType === "all" ? (
+                 <div className="space-y-2">
+                   <Label htmlFor="priceRangeFilter" className="text-slate-300">Price Range</Label>
+                   <Select
+                     value={filters.priceRange}
+                     onValueChange={(value: PriceRange | "all") => handleFilterChange("priceRange", value)}
+                     disabled={isLoading || filters.itemType === "attraction" || filters.itemType === "show" || filters.itemType === "event"}
+                   >
+                     <SelectTrigger id="priceRangeFilter" className="bg-slate-700 border-slate-600 text-white">
+                       <SelectValue placeholder="Select Price Range" />
+                     </SelectTrigger>
+                     <SelectContent className="bg-slate-700 border-slate-600 text-white">
+                       {PRICE_RANGE_OPTIONS.map(opt => (
+                         <SelectItem key={opt.value} value={opt.value} className="hover:bg-slate-600">{opt.label}</SelectItem>
+                       ))}
+                     </SelectContent>
+                   </Select>
+                 </div>
+               ) : null}
+ 
+               {/* Sort By */}
+               <div className="space-y-2">
+                 <Label htmlFor="sortBy" className="text-slate-300">Sort By</Label>
+                 <Select
+                   value={filters.sortBy}
+                   onValueChange={(value: "relevance" | "popularity" | "rating") => handleFilterChange("sortBy", value)}
+                   disabled={isLoading}
+                 >
+                   <SelectTrigger id="sortBy" className="bg-slate-700 border-slate-600 text-white">
+                     <SelectValue placeholder="Sort By" />
+                   </SelectTrigger>
+                   <SelectContent className="bg-slate-700 border-slate-600 text-white">
+                     {SORT_BY_OPTIONS.map(opt => (
+                       <SelectItem key={opt.value} value={opt.value} className="hover:bg-slate-600">{opt.label}</SelectItem>
+                     ))}
+                   </SelectContent>
+                 </Select>
+               </div>
+ 
+               {/* Genie+ & ILL Switches (Conditional) */}
+               {filters.itemType === "attraction" || filters.itemType === "all" ? (
+                 <>
+                   <div className="flex items-center space-x-2 pt-4">
+                     <Switch
+                       id="geniePlusSwitch"
+                       checked={filters.showOnlyAvailableGeniePlus}
+                       onCheckedChange={(checked) => handleFilterChange("showOnlyAvailableGeniePlus", checked)}
+                       disabled={isLoading || filters.itemType === "dining" || filters.itemType === "show" || filters.itemType === "event"}
+                       className="data-[state=checked]:bg-purple-500"
+                     />
+                     <Label htmlFor="geniePlusSwitch" className="text-slate-300">Only Genie+ Available</Label>
+                   </div>
+                   <div className="flex items-center space-x-2 pt-4">
+                     <Switch
+                       id="lightningLaneSwitch"
+                       checked={filters.showOnlyAvailableLightningLane}
+                       onCheckedChange={(checked) => handleFilterChange("showOnlyAvailableLightningLane", checked)}
+                       disabled={isLoading || filters.itemType === "dining" || filters.itemType === "show" || filters.itemType === "event"}
+                       className="data-[state=checked]:bg-purple-500"
+                     />
+                     <Label htmlFor="lightningLaneSwitch" className="text-slate-300">Only Ind. Lightning Lane Available</Label>
+                   </div>
+                 </>
+               ) : null}
+ 
+               {/* Max Wait Time Slider (Conditional) */}
+               {filters.itemType === "attraction" || filters.itemType === "all" ? (
+                 <div className="space-y-2 col-span-1 md:col-span-2 lg:col-span-1">
+                   <Label htmlFor="maxWaitTimeSlider" className="text-slate-300">Max Wait Time: {filters.maxWaitTime} min</Label>
+                   <Slider
+                     id="maxWaitTimeSlider"
+                     min={0}
+                     max={180}
+                     step={5}
+                     value={[filters.maxWaitTime || 120]}
+                     onValueChange={(value) => handleFilterChange("maxWaitTime", value[0])}
+                     disabled={isLoading || filters.itemType === "dining" || filters.itemType === "show" || filters.itemType === "event"}
+                     className="[&>span:first-child]:h-1 [&>span:first-child]:bg-purple-500"
+                   />
+                 </div>
+               ) : null}
+             </div>
+             <div className="mt-6 flex justify-end">
+               <Button onClick={handleResetFilters} variant="destructive_outline" size="sm" disabled={isLoading} className="group">
+                 <XCircle size={16} className="mr-2 transition-transform duration-300 group-hover:rotate-90" /> Reset Filters
+               </Button>
+             </div>
+           </AccordionContent>
+         </AccordionItem>
+       </Accordion>
+     </div>
+   )
+ }
```

---

Finally, I'll create the main `RecommendationEngine.tsx` component. This component will bring everything together: it will use the `useRecommendationLogic` hook to get recommendations, display them using `RecommendationCard` components, and allow users to filter these recommendations via the `RecommendationFilters` component. It will also handle loading and error states.

---

```diff
- 
+ "use client"
+ 
+ import React, { useState, useEffect } from "react"
+ import { motion, AnimatePresence } from "framer-motion"
+ import { Loader2, AlertTriangle, ListFilter, LayoutGrid, Rows, SearchX } from "lucide-react"
+ import { Button } from "@/components/ui/button"
+ import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
+ import { useRecommendationLogic } from "./use-recommendation-logic.hook"
+ import { RecommendationCard, RecommendationCardSkeleton } from "./recommendation-card"
+ import { RecommendationFilters } from "./recommendation-filters"
+ import {
+   RecommendationEngineProps,
+   RecommendableItem,
+   Recommendation,
+   RecommendationFilters as RecommendationFiltersType,
+ } from "./types"
+ import { DEFAULT_RECOMMENDATION_FILTERS } from "./constants"
+ 
+ // Placeholder for fetching actual data - replace with your data fetching solution
+ async function fetchMockItems(): Promise<RecommendableItem[]> {
+   // In a real app, this would be an API call
+   // For now, using a simplified mock structure. Ensure your actual data matches RecommendableItem types.
+   await new Promise(resolve => setTimeout(resolve, 100))
+   return [
+     // Add 5-10 diverse mock items here matching AttractionItem, DiningItem, ShowItem, EventItem structure
+     // Example Magic Kingdom Attractions
+     {
+       id: "mk-7dmt", type: "attraction", name: "Seven Dwarfs Mine Train", parkId: "magic-kingdom", attractionType: "thrill",
+       description: "Race through the diamond mine from Snow White and the Seven Dwarfs on a swaying family coaster.",
+       imageUrl: "/images/attractions/mk-7dmt.jpg", userRating: { average: 4.8, count: 15000 }, expectedWaitTime: 75, geniePlusAvailable: true, thrillLevel: "medium",
+       location: "Fantasyland", tags: ["coaster", "family", "mining"], heightRequirement: 97
+     },
+     {
+       id: "mk-hm", type: "attraction", name: "Haunted Mansion", parkId: "magic-kingdom", attractionType: "family",
+       description: "Climb aboard a gloomy Doom Buggy for a spooky tour through this house of happy haunts.",
+       imageUrl: "/images/attractions/mk-hm.jpg", userRating: { average: 4.6, count: 12000 }, expectedWaitTime: 45, individualLightningLaneAvailable: false, thrillLevel: "low",
+       location: "Liberty Square", tags: ["dark-ride", "classic", "ghosts"], accessibilityFeatures: ["wheelchair-accessible"]
+     },
+     // Example Epcot Dining
+     {
+       id: "ep-les-halles", type: "dining", name: "Les Halles Boulangerie-Patisserie", parkId: "epcot", diningType: "quick-service",
+       description: "Delight in French bakery classics, from sandwiches to pastries, in a charming Parisian setting.",
+       imageUrl: "/images/dining/ep-les-halles.jpg", userRating: { average: 4.5, count: 8000 }, priceRange: "$", cuisine: ["French", "Bakery"],
+       location: "World Showcase - France", mobileOrderAvailable: true
+     },
+     {
+       id: "ep-space-220", type: "dining", name: "Space 220 Restaurant", parkId: "epcot", diningType: "table-service",
+       description: "Dine among the stars in this out-of-this-world restaurant with panoramic views of Earth from 220 miles up.",
+       imageUrl: "/images/dining/ep-space-220.jpg", userRating: { average: 4.2, count: 3500 }, priceRange: "$$$", cuisine: ["Modern American"],
+       location: "World Discovery (Future World)", reservationsRecommended: true
+     },
+     // Example Hollywood Studios Show
+     {
+       id: "hs-fantasmic", type: "show", name: "Fantasmic!", parkId: "hollywood-studios", showType: "stage",
+       description: "Behold the forces of good and evil in Mickey's dream as they battle on water and light.",
+       imageUrl: "/images/shows/hs-fantasmic.jpg", userRating: { average: 4.9, count: 9500 }, duration: 30, showTimes: ["9:00 PM", "10:30 PM"],
+       location: "Hollywood Hills Amphitheater", tags: ["nighttime", "water-show", "fireworks-finale"]
+     },
+      // Example Animal Kingdom Event (placeholder)
+     {
+       id: "ak-earth-month", type: "event", name: "Earth Month Celebration", parkId: "animal-kingdom", eventType: "seasonal",
+       description: "Join Animal Kingdom in celebrating Earth Month with special activities, character meets, and conservation messages.",
+       imageUrl: "/images/events/ak-earth-month.jpg", userRating: { average: 4.3, count: 1200 }, eventDates: { startDate: new Date("2024-04-01"), endDate: new Date("2024-04-30") },
+       location: "Various locations", tags: ["conservation", "education", "limited-time"]
+     },
+     {
+       id: "mk-pirates", type: "attraction", name: "Pirates of the Caribbean", parkId: "magic-kingdom", attractionType: "family",
+       description: "Set sail on a swashbuckling voyage to a time when pirates ruled the seas.",
+       imageUrl: "/images/attractions/mk-pirates.jpg", userRating: { average: 4.7, count: 13500 }, expectedWaitTime: 35, thrillLevel: "low",
+       location: "Adventureland", tags: ["boat-ride", "classic", "audio-animatronics"]
+     },
+     {
+       id: "ep-test-track", type: "attraction", name: "Test Track", parkId: "epcot", attractionType: "thrill",
+       description: "Design a virtual concept car and then take it for a thrilling spin on the Test Track.",
+       imageUrl: "/images/attractions/ep-test-track.jpg", userRating: { average: 4.5, count: 11000 }, expectedWaitTime: 65, geniePlusAvailable: true, thrillLevel: "high",
+       location: "World Discovery (Future World)", heightRequirement: 102
+     }
+   ]
+ }
+ 
+ /**
+  * @component RecommendationEngine
+  * @description Main component for displaying and filtering recommendations.
+  * It fetches items, uses the recommendation logic hook, and renders cards and filters.
+  * Provides an immersive and interactive experience for discovering Disney park activities.
+  */
+ export function RecommendationEngine(props: RecommendationEngineProps) {
+   const [allItems, setAllItems] = useState<RecommendableItem[]>([])
+   const [initialLoading, setInitialLoading] = useState(true)
+   const [viewMode, setViewMode] = useState<"grid" | "list">("grid")
+   const [activeFilters, setActiveFilters] = useState<RecommendationFiltersType>(DEFAULT_RECOMMENDATION_FILTERS)
+ 
+   useEffect(() => {
+     async function loadItems() {
+       setInitialLoading(true)
+       try {
+         // In a real app, props.allItems might be passed directly or fetched via a more robust system.
+         // If props.allItems is not provided, we fetch mock items.
+         const itemsToUse = props.allItems && props.allItems.length > 0 ? props.allItems : await fetchMockItems();
+         setAllItems(itemsToUse)
+       } catch (error) {
+         console.error("Failed to load items for recommendation engine:", error)
+         // Potentially set an error state to display to the user
+       }
+       setInitialLoading(false)
+     }
+     loadItems()
+   }, [props.allItems]) // Re-fetch/re-set if props.allItems changes
+ 
+   const enginePropsWithFetchedItems: RecommendationEngineProps = {
+     ...props,
+     allItems: allItems,
+   }
+ 
+   const { recommendations, isLoading: recommendationsLoading, error, applyFilters } = useRecommendationLogic(enginePropsWithFetchedItems)
+ 
+   const handleFiltersChange = (newFilters: RecommendationFiltersType) => {
+     setActiveFilters(newFilters)
+     applyFilters(newFilters, recommendations) // Pass current recommendations to be filtered
+   }
+ 
+   const handleAddToItinerary = (item: RecommendableItem) => {
+     console.log("Add to Itinerary:", item.name) // Replace with actual logic
+     // Example: trackEvent('add_to_itinerary', { item_id: item.id, item_name: item.name });
+   }
+ 
+   const handleNotInterested = (itemId: string) => {
+     console.log("Not Interested:", itemId) // Replace with actual logic, e.g., update user preferences
+     // Example: trackEvent('hide_recommendation', { item_id: itemId });
+     // Potentially re-fetch or re-filter recommendations after this action
+   }
+ 
+   const isLoading = initialLoading || recommendationsLoading
+ 
+   const cardVariants = {
+     hidden: { opacity: 0, y: 20 },
+     visible: (i: number) => ({
+       opacity: 1,
+       y: 0,
+       transition: {
+         delay: i * 0.05,
+         duration: 0.3,
+         ease: "easeOut"
+       }
+     })
+   };
+ 
+   return (
+     <div className="container mx-auto py-8 px-4 bg-gradient-to-b from-slate-950 via-purple-950 to-black min-h-screen">
+       <div className="flex flex-col md:flex-row justify-between items-center mb-6 md:mb-8">
+         <h1 className="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 via-pink-500 to-orange-500 mb-4 md:mb-0">
+           Magical Suggestions For You
+         </h1>
+         <div className="flex items-center space-x-2">
+           <TooltipProvider>
+             <Tooltip>
+               <TooltipTrigger asChild>
+                 <Button variant={viewMode === 'grid' ? "secondary" : "ghost"} size="icon" onClick={() => setViewMode('grid')} className="text-white hover:bg-purple-700">
+                   <LayoutGrid size={20} />
+                 </Button>
+               </TooltipTrigger>
+               <TooltipContent className="bg-slate-800 text-white border-slate-700"><p>Grid View</p></TooltipContent>
+             </Tooltip>
+             <Tooltip>
+               <TooltipTrigger asChild>
+                 <Button variant={viewMode === 'list' ? "secondary" : "ghost"} size="icon" onClick={() => setViewMode('list')} className="text-white hover:bg-purple-700">
+                   <Rows size={20} />
+                 </Button>
+               </TooltipTrigger>
+               <TooltipContent className="bg-slate-800 text-white border-slate-700"><p>List View</p></TooltipContent>
+             </Tooltip>
+           </TooltipProvider>
+         </div>
+       </div>
+ 
+       <RecommendationFilters
+         initialFilters={DEFAULT_RECOMMENDATION_FILTERS}
+         onFiltersChange={handleFiltersChange}
+         isLoading={isLoading}
+       />
+ 
+       {error && (
+         <motion.div
+           initial={{ opacity: 0, y: -20 }}
+           animate={{ opacity: 1, y: 0 }}
+           className="flex flex-col items-center justify-center p-6 mb-6 bg-red-900/30 border border-red-700 rounded-lg text-red-300 text-center"
+         >
+           <AlertTriangle size={48} className="mb-3 text-red-500" />
+           <h3 className="text-xl font-semibold mb-2">Oops! Something went wrong.</h3>
+           <p>{error}</p>
+           <Button onClick={() => applyFilters(activeFilters, recommendations)} variant="outline" className="mt-4 text-red-300 border-red-500 hover:bg-red-800/50 hover:text-red-200">
+             Try Reloading Suggestions
+           </Button>
+         </motion.div>
+       )}
+ 
+       {isLoading && recommendations.length === 0 && (
+         <div className={`grid gap-4 md:gap-6 ${viewMode === 'grid' ? 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4' : 'grid-cols-1'}`}>
+           {Array.from({ length: props.maxRecommendations || 8 }).map((_, index) => (
+             <RecommendationCardSkeleton key={`skel-${index}`} />
+           ))}
+         </div>
+       )}
+ 
+       {!isLoading && recommendations.length === 0 && !error && (
+         <motion.div
+           initial={{ opacity: 0, scale: 0.9 }}
+           animate={{ opacity: 1, scale: 1 }}
+           className="flex flex-col items-center justify-center p-10 my-10 bg-slate-800/50 border border-slate-700 rounded-lg text-slate-400 text-center shadow-xl"
+         >
+           <SearchX size={64} className="mb-6 text-purple-400" />
+           <h3 className="text-2xl font-semibold mb-3 text-slate-200">No Recommendations Found</h3>
+           <p className="max-w-md">
+             We couldn't find any recommendations matching your current preferences and filters.
+             Try adjusting your filter settings or broadening your choices!
+           </p>
+         </motion.div>
+       )}
+ 
+       {!isLoading && recommendations.length > 0 && (
+         <motion.div
+           className={`grid gap-4 md:gap-6 ${viewMode === 'grid' ? 'grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4' : 'grid-cols-1'}`}
+           initial="hidden"
+           animate="visible"
+         >
+           <AnimatePresence>
+             {recommendations.map((rec, index) => (
+               <motion.div key={rec.item.id} custom={index} variants={cardVariants} layout>
+                 <RecommendationCard
+                   recommendation={rec}
+                   onAddToItinerary={handleAddToItinerary}
+                   onNotInterested={handleNotInterested}
+                   isLoading={isLoading} // Individual card loading not implemented, but prop exists
+                 />
+               </motion.div>
+             ))}
+           </AnimatePresence>
+         </motion.div>
+       )}
+     </div>
+   )
+ }
```

---

The sophisticated recommendation engine components are now created. This includes:

*   **`types.ts`**: Defines all necessary TypeScript interfaces for user preferences, various recommendable items (attractions, dining, shows, events), and the structure of a recommendation.
*   **`constants.ts`**: Contains default filter values, options for selection UI (parks, item types, etc.), and scoring weights that can be tuned.
*   **`utils.ts`**: Provides helper functions for formatting, display logic, and a debounce utility.
*   **`use-recommendation-logic.hook.ts`**: Encapsulates the core recommendation generation logic, including item scoring based on multiple criteria (popularity, user preferences, context, history, hidden gems) and basic diversity handling. It's designed to be extensible for future backend integrations like collaborative filtering or ML models.
*   **`recommendation-card.tsx`**: A visually rich component to display individual recommendations with details, images, reasoning, and action buttons. It also includes a skeleton loader for a smooth UX.
*   **`recommendation-filters.tsx`**: A collapsible UI component allowing users to filter and sort recommendations by various criteria, built with Shadcn UI components.
*   **`recommendation-engine.tsx`**: The main orchestrator component. It handles fetching/setting item data, uses the logic hook, integrates the filters, displays recommendations in a grid or list view, and manages loading, error, and empty states with an immersive design and animations.
*   **`index.ts`**: Exports the primary components for easy import.

This structure provides a solid foundation for a very detailed and sophisticated recommendation system. The current implementation relies on client-side logic with mock data fetching but is architected to easily integrate with a more powerful backend for advanced recommendation strategies as your application evolves. Remember to replace the `fetchMockItems` function with your actual data fetching mechanism and to implement the `onAddToItinerary` and `onNotInterested` handlers with your application's specific logic. You'll also need to ensure placeholder images are available at the paths specified or update the image URLs.

---

