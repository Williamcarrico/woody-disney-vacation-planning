<!-- Generated by SpecStory -->

# Fixing maximum update depth exceeded error (2025-06-11 13:34:01)

_**User**_

Error: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render.
    at createConsoleError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_8f19e6fb._.js:882:71)
    at handleConsoleError (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_8f19e6fb._.js:1058:54)
    at console.error (http://localhost:3000/_next/static/chunks/node_modules_next_dist_client_8f19e6fb._.js:1223:57)
    at getRootForUpdatedFiber (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:4741:143)
    at enqueueConcurrentHookUpdate (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:4724:16)
    at dispatchSetStateInternal (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:7189:22)
    at dispatchSetState (http://localhost:3000/_next/static/chunks/node_modules_next_dist_compiled_2ce9398a._.js:7161:9)
    at SparklesText.useEffect.updateStars (http://localhost:3000/_next/static/chunks/src_de1ac3ec._.js:2275:21)

---

_**Assistant**_

I can see you're experiencing a "Maximum update depth exceeded" error, which is a common React issue that occurs when a component gets stuck in an infinite re-render loop. The error is specifically happening in a `SparklesText` component where `setState` is being called inside a `useEffect`.

Let me search for the SparklesText component to identify and fix the issue.

---

<details>
            <summary>Searched codebase "SparklesText component useEffect updateStars" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/components/magicui/sparkles-text.tsx` | L85-150 |
| `src/components/magicui/sparkles-text.tsx` | L1-16 |
| `src/components/magicui/sparkles-text.tsx` | L40-85 |
| `src/components/magicui/sparkles-text.tsx` | L16-40 |
| `src/app/dashboard/settings/components/settings-header.tsx` | L1-15 |
| `src/app/annual-passes/page.tsx` | L149-185 |
| `src/components/shared/footer/ParticleField.tsx` | L97-134 |
| `src/components/shared/footer/ParticleField.tsx` | L67-97 |
| `src/components/shared/Navbar.tsx` | L428-467 |
| `src/components/dashboard/SmartRecommendationsDashboard.tsx` | L338-371 |
| `src/app/annual-passes/page.tsx` | L292-325 |
| `src/app/dashboard/parks/hollywood-studios/page.tsx` | L938-953 |
| `src/components/theme-provider/theme-showcase.tsx` | L27-73 |
| `src/app/annual-passes/page.tsx` | L349-369 |
| `src/components/dashboard/DashboardHeader.tsx` | L112-128 |
| `src/components/theme-provider/theme-utils.ts` | L337-392 |
| `src/app/page.tsx` | L153-196 |
| `src/components/dashboard/SmartRecommendationsDashboard.tsx` | L371-403 |
| `src/app/(auth)/signup/page.tsx` | L379-420 |
| `src/components/magicui/meteors.tsx` | L22-48 |
| `src/app/dashboard/parks/magic-kingdom/page.tsx` | L483-502 |
| `src/app/dashboard/parks/epcot/page.tsx` | L1870-1890 |
| `src/app/dashboard/parks/history/page.tsx` | L255-283 |
| `src/app/dashboard/messages/page.tsx` | L489-510 |
| `src/components/ui/meteors.tsx` | L22-66 |

</details>

---

Now I can see the issue! Looking at the `SparklesText` component in `src/components/magicui/sparkles-text.tsx`, the problem is in the `useEffect` dependency array. The `colors` object is being passed as a dependency, but objects in JavaScript are compared by reference, not by value. This means that even if the `colors` prop has the same values, if it's a new object instance on each render, it will trigger the `useEffect` to run again, causing an infinite loop.

Let me examine the component more closely:

---

Read file: src/components/magicui/sparkles-text.tsx

---

Perfect! I can see the exact issue. The problem is on line 130 in the dependency array:

```typescript
}, [colors.first, colors.second, sparklesCount]);
```

The issue is that when `colors` is passed as a prop without being memoized, and especially when it's passed as an inline object (like `colors={{ first: "#3B82F6", second: "#EC4899" }}`), it creates a new object reference on every render. This causes the `useEffect` to run continuously, creating an infinite loop.

Let me check how the component is being used to confirm this:

---

<details>
            <summary>Grep search for "SparklesText.*colors.*=.*{" • **0** files</summary>
        
No results found
</details>

---

<details>
            <summary>Grep search for "colors=\{.*first.*second" • **1** files</summary>
        
| File | Line | Match |
|------|------|-------|
| `file:///Users/williamcarrico/Web%20App%20Design/woody-disney-vacation-planning/src/components/shared/Navbar.tsx` | L435 | `colors={{ first: "#3B82F6", second: "#EC4899" }}` |

</details>

---

Found it! The issue is in the Navbar component where `SparklesText` is being used with an inline `colors` object. This creates a new object on every render, causing the infinite loop.

Now I'll fix this issue by modifying the `SparklesText` component to use `useMemo` to memoize the colors and prevent the infinite re-renders:

---

```diff
  
  import { motion } from "motion/react";
- import { CSSProperties, ReactElement, useEffect, useState } from "react";
+ import { CSSProperties, ReactElement, useEffect, useState, useMemo } from "react";
  
  import { cn } from "@/lib/utils";
```

```diff
  }) => {
    const [sparkles, setSparkles] = useState<Sparkle[]>([]);
+ 
+   // Memoize colors to prevent unnecessary re-renders
+   const memoizedColors = useMemo(() => ({
+     first: colors.first,
+     second: colors.second
+   }), [colors.first, colors.second]);
  
    useEffect(() => {
      const generateStar = (): Sparkle => {
        const starX = `${Math.random() * 100}%`;
        const starY = `${Math.random() * 100}%`;
-       const color = Math.random() > 0.5 ? colors.first : colors.second;
+       const color = Math.random() > 0.5 ? memoizedColors.first : memoizedColors.second;
        const delay = Math.random() * 2;
        const scale = Math.random() * 1 + 0.3;
```

```diff
  
      return () => clearInterval(interval);
-   }, [colors.first, colors.second, sparklesCount]);
+   }, [memoizedColors.first, memoizedColors.second, sparklesCount]);
  
    return (
```

```diff
        style={
          {
-           "--sparkles-first-color": `${colors.first}`,
-           "--sparkles-second-color": `${colors.second}`,
+           "--sparkles-first-color": `${memoizedColors.first}`,
+           "--sparkles-second-color": `${memoizedColors.second}`,
          } as CSSProperties
        }
```

---

Great! I've fixed the infinite re-render issue in the `SparklesText` component. Here's what I changed:

1. **Added `useMemo` import** to the React imports
2. **Created `memoizedColors`** using `useMemo` to prevent the colors object from being recreated on every render
3. **Updated all references** to use `memoizedColors` instead of the direct `colors` prop
4. **Updated the dependency array** to use the memoized colors

The key issue was that when `colors` is passed as an inline object (like `colors={{ first: "#3B82F6", second: "#EC4899" }}` in the Navbar), it creates a new object reference on every render. This caused the `useEffect` to run continuously because the dependency array `[colors.first, colors.second, sparklesCount]` would see different object references each time.

By using `useMemo`, we ensure that the colors object is only recreated when the actual color values change, not when the parent component re-renders with the same color values.

The fix should resolve the "Maximum update depth exceeded" error you were experiencing. The component will now only re-initialize the sparkles when the color values actually change, rather than on every render.

---

