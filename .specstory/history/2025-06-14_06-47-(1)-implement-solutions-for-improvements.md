<!-- Generated by SpecStory -->

# (1) Implement solutions for improvements (2025-06-14 01:47:50)

_**User**_

your task is to implement solutions to resolve these improvments

---

_**Assistant**_



---

I'll help you implement solutions for these immediate improvements. Let me first examine the current state of these components to understand what needs to be addressed.

---

Read file: src/components/magicui/custom-cursor.tsx

---

Read file: src/components/shared/Header.tsx

---

<details>
            <summary>Listed directory src/app/api • **27** results</summary>
        
| Name |
|-------|
| 📁 `dining` |
| 📁 `attractions` |
| 📁 `resorts-simple` |
| 📁 `test-resorts` |
| 📁 `vacations` |
| 📁 `user` |
| 📁 `crowds` |
| 📁 `health` |
| 📁 `parks` |
| 📁 `walt-disney-world` |
| 📁 `unified` |
| 📁 `disney` |
| 📁 `destinations` |
| 📁 `resorts` |
| 📁 `messages` |
| 📁 `socket` |
| 📁 `analytics` |
| 📁 `weather` |
| 📁 `restaurants` |
| 📁 `geofences` |
| 📁 `itinerary` |
| 📄 `config.ts` |
| 📁 `maps` |
| 📁 `auth` |
| 📁 `historical` |
| 📁 `genie` |
| 📁 `virtualqueues` |

</details>

---

Read file: src/lib/cache/redis-cache-service.ts

---

Read file: src/lib/api/auth-middleware.ts

---

Now let me check if there are any existing auth middleware files or if I need to create them:

---

Read file: src/lib/api/rate-limit-middleware.ts

---

Perfect! Now I have a good understanding of the current state. Let me implement the four key improvements:

## 1. Fix Custom Cursor Accessibility Issues

---

```diff
    const [mouseTrail, setMouseTrail] = useState<Array<{ x: number; y: number; id: number }>>([])
    const [isKeyboardUser, setIsKeyboardUser] = useState(false)
+   const [lastInteractionType, setLastInteractionType] = useState<'mouse' | 'keyboard' | null>(null)
    
    const prefersReducedMotion = useReducedMotion()
```

```diff
    const trailIdRef = useRef(0)
    const animationIdRef = useRef<number>()
+   const keyboardTimeoutRef = useRef<NodeJS.Timeout>()
    
    const springConfig = { damping: 30, stiffness: 800 }
```

```diff
    }), [])
  
-   // Detect keyboard usage for accessibility
+   // Enhanced keyboard usage detection with better accessibility
    useEffect(() => {
      const handleKeyDown = (e: KeyboardEvent) => {
-       if (e.key === 'Tab' || e.key === 'Enter' || e.key === ' ' || e.key.startsWith('Arrow')) {
+       // More comprehensive keyboard detection
+       const keyboardKeys = [
+         'Tab', 'Enter', 'Space', 'Escape', 'ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight',
+         'Home', 'End', 'PageUp', 'PageDown', 'Insert', 'Delete', 'Backspace'
+       ]
+       
+       if (keyboardKeys.includes(e.key) || e.key.startsWith('F') || e.altKey || e.ctrlKey || e.metaKey) {
          setIsKeyboardUser(true)
-       }
+         setLastInteractionType('keyboard')
+         
+         // Reset keyboard timeout
+         if (keyboardTimeoutRef.current) {
+           clearTimeout(keyboardTimeoutRef.current)
+         }
+         
+         // Only show cursor again after prolonged mouse usage
+         keyboardTimeoutRef.current = setTimeout(() => {
+           if (lastInteractionType === 'mouse') {
+             setIsKeyboardUser(false)
+           }
+         }, 2000)
+       }
      }
  
-     const handleMouseMove = () => {
-       setIsKeyboardUser(false)
-     }
- 
-     document.addEventListener('keydown', handleKeyDown)
-     document.addEventListener('mousemove', handleMouseMove, { once: true })
+     const handleMouseMove = (e: MouseEvent) => {
+       // Only switch to mouse mode if there's actual movement
+       if (e.movementX !== 0 || e.movementY !== 0) {
+         setLastInteractionType('mouse')
+         
+         // Only disable keyboard mode after sustained mouse movement
+         if (keyboardTimeoutRef.current) {
+           clearTimeout(keyboardTimeoutRef.current)
+         }
+         
+         keyboardTimeoutRef.current = setTimeout(() => {
+           setIsKeyboardUser(false)
+         }, 500)
+       }
+     }
+ 
+     const handleFocusIn = () => {
+       setIsKeyboardUser(true)
+       setLastInteractionType('keyboard')
+     }
+ 
+     // Add proper event listeners with capture for better detection
+     document.addEventListener('keydown', handleKeyDown, { capture: true })
+     document.addEventListener('mousemove', handleMouseMove, { passive: true })
+     document.addEventListener('focusin', handleFocusIn, { capture: true })
  
      return () => {
-       document.removeEventListener('keydown', handleKeyDown)
+       document.removeEventListener('keydown', handleKeyDown, { capture: true })
        document.removeEventListener('mousemove', handleMouseMove)
+       document.removeEventListener('focusin', handleFocusIn, { capture: true })
+       
+       if (keyboardTimeoutRef.current) {
+         clearTimeout(keyboardTimeoutRef.current)
+       }
      }
-   }, [])
+   }, [lastInteractionType])
  
    useEffect(() => {
      setIsMounted(true)
    }, [])
  
-   // Animation loop for fairy dust
+   // Optimized animation loop with performance improvements
    useEffect(() => {
-     if (!isMounted) return
+     if (!isMounted || shouldDisableCursor) return
  
      const updateFairyDust = () => {
-       setFairyDust(prevDust => 
-         prevDust
+       setFairyDust(prevDust => {
+         const updatedDust = prevDust
            .map(particle => ({
              ...particle,
```

```diff
            }))
            .filter(particle => particle.life < particle.maxLife)
-       )
+         
+         // Limit particles for performance
+         return updatedDust.slice(0, 30)
+       })
        
-       animationIdRef.current = requestAnimationFrame(updateFairyDust)
+       if (!shouldDisableCursor) {
+         animationIdRef.current = requestAnimationFrame(updateFairyDust)
+       }
      }
  
```

```diff
        }
      }
-   }, [isMounted])
+   }, [isMounted, shouldDisableCursor])
  
    useEffect(() => {
-     if (!isMounted) return
+     if (!isMounted || shouldDisableCursor) return
  
      const moveCursor = (e: MouseEvent) => {
```

```diff
        setIsVisible(true)
  
-       // Add to mouse trail
+       // Throttled mouse trail for performance
        const newPoint = { x: e.clientX, y: e.clientY, id: trailIdRef.current++ }
-       setMouseTrail(prev => [newPoint, ...prev].slice(0, 12))
+       setMouseTrail(prev => [newPoint, ...prev].slice(0, 8)) // Reduced trail length
  
-       // Generate fairy dust particles on movement
-       if (cursorVariant === 'fairy' || cursorVariant === 'magical') {
-         if (Math.random() > 0.7) { // 30% chance per movement
-           const newParticles = Array.from({ length: Math.floor(Math.random() * 3) + 1 }, () =>
-             createFairyDustParticle(e.clientX, e.clientY)
-           )
-           setFairyDust(prev => [...prev, ...newParticles].slice(-50)) // Keep max 50 particles
-         }
+       // Generate fairy dust particles on movement (reduced frequency)
+       if ((cursorVariant === 'fairy' || cursorVariant === 'magical') && Math.random() > 0.85) {
+         const newParticles = Array.from({ length: Math.floor(Math.random() * 2) + 1 }, () =>
+           createFairyDustParticle(e.clientX, e.clientY)
+         )
+         setFairyDust(prev => [...prev, ...newParticles].slice(-30)) // Reduced max particles
        }
      }
```

```diff
          const isLink = target.closest('a') !== null
          const isRoleButton = target.closest('[role="button"]') !== null
+         const isInteractive = target.closest('[tabindex]') !== null
          const isSparkleZone = target.closest('.sparkle-zone') !== null
          const isFairyZone = target.closest('.fairy-zone') !== null
          
-         if (isButton || isLink || isRoleButton) {
+         if (isButton || isLink || isRoleButton || isInteractive) {
            setIsHovering(true)
            setCursorVariant('magical')
```

```diff
          console.warn('CustomCursor: Element interaction error:', error)
          setIsHovering(false)
-         setCursorVariant('fairy')
+         setCursorVariant('default')
        }
      }
  
      const handleMouseLeave = () => {
        setIsHovering(false)
-       setCursorVariant('fairy')
+       setCursorVariant('default')
      }
  
      const handleMouseDown = (e: MouseEvent) => {
-       setCursorVariant('sparkle')
-       // Create burst of fairy dust on click
-       const burstParticles = Array.from({ length: 8 }, () =>
-         createFairyDustParticle(e.clientX, e.clientY)
-       )
-       setFairyDust(prev => [...prev, ...burstParticles].slice(-50))
+       // Create burst effect on click
+       if (cursorVariant !== 'default') {
+         const burstParticles = Array.from({ length: 5 }, () =>
+           createFairyDustParticle(e.clientX, e.clientY)
+         )
+         setFairyDust(prev => [...prev, ...burstParticles].slice(-30))
+       }
      }
  
      const handleMouseUp = () => {
-       setCursorVariant(isHovering ? 'magical' : 'fairy')
+       // Reset cursor scale after click
+     }
+ 
+     const handleMouseOut = () => {
+       setIsVisible(false)
      }
  
-     window.addEventListener('mousemove', moveCursor, { passive: true })
-     document.addEventListener('mouseenter', handleMouseEnter, { capture: true, passive: true })
-     document.addEventListener('mouseleave', handleMouseLeave, { capture: true, passive: true })
+     // Use passive listeners for better performance
+     document.addEventListener('mousemove', moveCursor, { passive: true })
+     document.addEventListener('mouseenter', handleMouseEnter, { passive: true, capture: true })
+     document.addEventListener('mouseleave', handleMouseLeave, { passive: true })
      document.addEventListener('mousedown', handleMouseDown, { passive: true })
      document.addEventListener('mouseup', handleMouseUp, { passive: true })
+     document.addEventListener('mouseout', handleMouseOut, { passive: true })
  
      return () => {
-       window.removeEventListener('mousemove', moveCursor)
-       document.removeEventListener('mouseenter', handleMouseEnter, true)
-       document.removeEventListener('mouseleave', handleMouseLeave, true)
+       document.removeEventListener('mousemove', moveCursor)
+       document.removeEventListener('mouseenter', handleMouseEnter, { capture: true })
+       document.removeEventListener('mouseleave', handleMouseLeave)
        document.removeEventListener('mousedown', handleMouseDown)
        document.removeEventListener('mouseup', handleMouseUp)
-     }
-   }, [cursorX, cursorY, isHovering, isMounted, cursorVariant])
- 
-   // Add data attribute to body for cursor state
-   useEffect(() => {
-     if (isMounted && !shouldDisableCursor) {
-       document.body.classList.add('custom-cursor-enabled')
-       document.body.setAttribute('data-keyboard-user', isKeyboardUser.toString())
-     } else {
-       document.body.classList.remove('custom-cursor-enabled')
-       document.body.removeAttribute('data-keyboard-user')
+       document.removeEventListener('mouseout', handleMouseOut)
      }
- 
-     return () => {
-       document.body.classList.remove('custom-cursor-enabled')
-       document.body.removeAttribute('data-keyboard-user')
-     }
-   }, [isMounted, shouldDisableCursor, isKeyboardUser])
+   }, [cursorX, cursorY, isMounted, shouldDisableCursor, cursorVariant, createFairyDustParticle])
  
-   // Don't render custom cursor if disabled or not visible
-   if (!isMounted || !isVisible || shouldDisableCursor) return null
- 
-   const variants = {
-     default: {
-       scale: 1,
-       rotate: 0,
-       background: 'radial-gradient(circle, rgba(255, 215, 0, 0.8), rgba(255, 105, 180, 0.4))',
-     },
-     magical: {
-       scale: 1.8,
-       rotate: [0, 360],
-       background: 'radial-gradient(circle, rgba(255, 105, 180, 0.9), rgba(156, 64, 255, 0.6), rgba(255, 170, 64, 0.4))',
-     },
-     sparkle: {
-       scale: 2.2,
-       rotate: [0, 180, 360],
-       background: 'radial-gradient(circle, rgba(255, 170, 64, 1), rgba(255, 105, 180, 0.8))',
-     },
-     fairy: {
-       scale: [1, 1.2, 1],
-       rotate: 0,
-       background: 'radial-gradient(circle, rgba(255, 215, 0, 0.7), rgba(221, 160, 221, 0.5), rgba(135, 206, 235, 0.3))',
-     }
+   // Don't render if should be disabled
+   if (!isMounted || shouldDisableCursor) {
+     return null
    }
  
    return (
      <>
-       {/* Conditionally hide default cursor with accessibility considerations */}
-       <style jsx global>{`
-         ${!shouldDisableCursor ? `
-           .custom-cursor-enabled * {
-             cursor: none !important;
-           }
-           
-           /* Preserve cursor for focusable elements when using keyboard */
-           .custom-cursor-enabled *:focus,
-           .custom-cursor-enabled *:focus-visible,
-           .custom-cursor-enabled button:focus,
-           .custom-cursor-enabled a:focus,
-           .custom-cursor-enabled input:focus,
-           .custom-cursor-enabled textarea:focus,
-           .custom-cursor-enabled select:focus,
-           .custom-cursor-enabled [tabindex]:focus {
-             cursor: auto !important;
-           }
-           
-           /* Restore cursor for screen reader users */
-           .custom-cursor-enabled[data-keyboard-user="true"] * {
-             cursor: auto !important;
-           }
-           
-           /* High contrast mode support */
-           @media (prefers-contrast: high) {
-             .custom-cursor-enabled * {
-               cursor: auto !important;
-             }
-           }
-           
-           /* Forced colors mode (Windows High Contrast) */
-           @media (forced-colors: active) {
-             .custom-cursor-enabled * {
-               cursor: auto !important;
-             }
-           }
-         ` : ''}
-       `}</style>
- 
-       {/* Mouse trail stars */}
-       <AnimatePresence>
-         {mouseTrail.slice(0, 6).map((point, index) => (
-           <motion.div
-             key={point.id}
-             className="pointer-events-none fixed z-[9996]"
-             style={{
-               left: point.x - 8,
-               top: point.y - 8,
-             }}
-             initial={{ scale: 0, opacity: 0.8 }}
-             animate={{ 
-               scale: 0.6 - (index * 0.08),
-               opacity: 0.8 - (index * 0.12),
-               rotate: index * 45
-             }}
-             exit={{ scale: 0, opacity: 0 }}
-             transition={{ duration: 0.6, ease: "easeOut" }}
-           >
-             <Star 
-               className="w-4 h-4 text-yellow-300 fill-yellow-300/60" 
-               style={{
-                 filter: 'drop-shadow(0 0 4px rgba(255, 215, 0, 0.8))'
-               }}
-             />
-           </motion.div>
-         ))}
-       </AnimatePresence>
- 
-       {/* Main cursor with magical aura */}
-       <motion.div
-         className="pointer-events-none fixed z-[9999] rounded-full"
-         style={{
-           left: cursorXSpring,
-           top: cursorYSpring,
-         }}
-         animate={variants[cursorVariant]}
-         transition={{ 
-           type: 'spring', 
-           stiffness: 400, 
-           damping: 25,
-           rotate: { duration: 2, repeat: Infinity, ease: "linear" }
-         }}
-       >
-         {/* Inner glow */}
-         <div className="w-6 h-6 rounded-full bg-gradient-to-br from-yellow-300/80 to-pink-400/60 blur-sm" />
-         
-         {/* Core star */}
-         <div className="absolute inset-0 flex items-center justify-center">
-           <Star className="w-3 h-3 text-white fill-white/90 drop-shadow-lg" />
-         </div>
-       </motion.div>
+       {/* Screen reader announcement for accessibility */}
+       <div 
+         className="sr-only" 
+         aria-live="polite" 
+         aria-atomic="true"
+         role="status"
+       >
+         {isKeyboardUser ? 'Keyboard navigation mode active' : 'Mouse interaction mode active'}
+       </div>
+ 
+       {/* Cursor container with proper accessibility attributes */}
+       <div 
+         className="fixed inset-0 pointer-events-none z-[9999]"
+         role="presentation"
+         aria-hidden="true"
+       >
+         <AnimatePresence>
+           {isVisible && (
+             <>
+               {/* Main cursor */}
+               <motion.div
+                 className={cn(
+                   'fixed top-0 left-0 w-8 h-8 rounded-full pointer-events-none z-[9999] mix-blend-difference',
+                   {
+                     'bg-white': cursorVariant === 'default',
+                     'bg-gradient-to-r from-red-500 to-blue-500': cursorVariant === 'magical',
+                     'bg-gradient-to-r from-yellow-400 to-pink-500': cursorVariant === 'sparkle',
+                     'bg-gradient-to-r from-purple-400 to-pink-500': cursorVariant === 'fairy',
+                   }
+                 )}
+                 style={{
+                   x: cursorXSpring,
+                   y: cursorYSpring,
+                 }}
+                 initial={{ scale: 0, opacity: 0 }}
+                 animate={{ 
+                   scale: isHovering ? 1.5 : 1, 
+                   opacity: 1,
+                 }}
+                 exit={{ scale: 0, opacity: 0 }}
+                 transition={{ 
+                   type: "spring", 
+                   stiffness: 500, 
+                   damping: 30,
+                   opacity: { duration: 0.2 }
+                 }}
+               />
+ 
+               {/* Cursor icon overlay */}
+               {(cursorVariant === 'magical' || cursorVariant === 'sparkle') && (
+                 <motion.div
+                   className="fixed top-0 left-0 pointer-events-none z-[10000]"
+                   style={{
+                     x: cursorXSpring,
+                     y: cursorYSpring,
+                   }}
+                   initial={{ scale: 0 }}
+                   animate={{ scale: 1 }}
+                   exit={{ scale: 0 }}
+                 >
+                   {cursorVariant === 'magical' && (
+                     <Sparkles className="w-4 h-4 text-white translate-x-2 translate-y-2" />
+                   )}
+                   {cursorVariant === 'sparkle' && (
+                     <Star className="w-4 h-4 text-white translate-x-2 translate-y-2" />
+                   )}
+                 </motion.div>
+               )}
  
-       {/* Outer magical ring */}
-       <motion.div
-         className="pointer-events-none fixed z-[9998] w-12 h-12 rounded-full border border-white/30"
-         style={{
-           left: cursorXSpring,
-           top: cursorYSpring,
-           transform: 'translate(-18px, -18px)',
-           background: 'conic-gradient(from 0deg, transparent, rgba(255, 215, 0, 0.3), transparent, rgba(255, 105, 180, 0.3), transparent)',
-         }}
-         animate={{
-           rotate: 360,
-           scale: cursorVariant === 'magical' ? 1.5 : 1,
-         }}
-         transition={{
-           rotate: { duration: 4, repeat: Infinity, ease: "linear" },
-           scale: { duration: 0.3 }
-         }}
-       />
- 
-       {/* Orbiting sparkles */}
-       {(cursorVariant === 'magical' || cursorVariant === 'fairy') && (
-         <>
-           {Array.from({ length: 8 }).map((_, i) => (
-             <motion.div
-               key={`orbit-${i}`}
-               className="pointer-events-none fixed z-[9997]"
-               style={{
-                 left: cursorXSpring,
-                 top: cursorYSpring,
-               }}
-               animate={{
-                 x: Math.cos((i * Math.PI * 2) / 8) * (cursorVariant === 'magical' ? 35 : 25),
-                 y: Math.sin((i * Math.PI * 2) / 8) * (cursorVariant === 'magical' ? 35 : 25),
-                 rotate: 360,
-                 opacity: [0.3, 1, 0.3],
-                 scale: [0.5, 1, 0.5],
-               }}
-               transition={{
-                 duration: 3,
-                 repeat: Infinity,
-                 delay: i * 0.2,
-                 ease: 'easeInOut',
-               }}
-             >
-               <div 
-                 className="w-2 h-2 rounded-full blur-sm"
-                 style={{
-                   background: fairyColors[i % fairyColors.length],
-                   boxShadow: `0 0 8px ${fairyColors[i % fairyColors.length]}`,
-                 }}
-               />
-             </motion.div>
-           ))}
-         </>
-       )}
- 
-       {/* Fairy dust particles */}
-       <AnimatePresence>
-         {fairyDust.map((particle) => {
-           const opacity = 1 - (particle.life / particle.maxLife)
-           const scale = (1 - (particle.life / particle.maxLife)) * (particle.size / 6)
-           
-           return (
-             <motion.div
-               key={particle.id}
-               className="pointer-events-none fixed z-[9995]"
-               style={{
-                 left: particle.x - particle.size / 2,
-                 top: particle.y - particle.size / 2,
-                 width: particle.size,
-                 height: particle.size,
-               }}
-               initial={{ opacity: 0, scale: 0 }}
-               animate={{ 
-                 opacity: opacity * 0.8,
-                 scale: scale,
-                 rotate: particle.sparkle ? 360 : 0,
-               }}
-               exit={{ opacity: 0, scale: 0 }}
-               transition={{ 
-                 opacity: { duration: 0.1 },
-                 scale: { duration: 0.2 },
-                 rotate: { duration: 2, repeat: Infinity, ease: "linear" }
-               }}
-             >
-               {particle.sparkle ? (
-                 <Sparkles 
-                   className="w-full h-full"
-                   style={{ 
-                     color: particle.color,
-                     filter: `drop-shadow(0 0 4px ${particle.color})`,
-                   }}
-                 />
-               ) : (
-                 <div 
-                   className="w-full h-full rounded-full blur-sm"
-                   style={{
-                     background: particle.color,
-                     boxShadow: `0 0 6px ${particle.color}`,
+               {/* Optimized mouse trail */}
+               {mouseTrail.slice(0, 6).map((point, index) => (
+                 <motion.div
+                   key={point.id}
+                   className="fixed w-2 h-2 bg-white rounded-full pointer-events-none mix-blend-difference"
+                   style={{
+                     left: point.x - 4,
+                     top: point.y - 4,
+                   }}
+                   initial={{ scale: 0.5, opacity: 0.8 }}
+                   animate={{ 
+                     scale: 0.3 - (index * 0.05), 
+                     opacity: 0.8 - (index * 0.15) 
+                   }}
+                   transition={{ duration: 0.3 }}
+                 />
+               ))}
+ 
+               {/* Optimized fairy dust particles */}
+               {fairyDust.slice(0, 20).map((particle) => (
+                 <motion.div
+                   key={particle.id}
+                   className="fixed pointer-events-none rounded-full"
+                   style={{
+                     left: particle.x - particle.size / 2,
+                     top: particle.y - particle.size / 2,
+                     width: particle.size,
+                     height: particle.size,
+                     backgroundColor: particle.color,
+                     opacity: Math.max(0, 1 - (particle.life / particle.maxLife)),
+                   }}
+                   initial={{ scale: 0 }}
+                   animate={{ 
+                     scale: particle.sparkle ? [1, 1.5, 1] : 1,
+                   }}
+                   transition={{ 
+                     scale: { 
+                       duration: 0.5, 
+                       repeat: particle.sparkle ? Infinity : 0,
+                       repeatType: 'reverse' 
+                     } 
                    }}
                  />
-               )}
-             </motion.div>
-           )
-         })}
-       </AnimatePresence>
- 
-       {/* Special click burst effect */}
-       {cursorVariant === 'sparkle' && (
-         <motion.div
-           className="pointer-events-none fixed z-[9997]"
-           style={{
-             left: cursorXSpring,
-             top: cursorYSpring,
-           }}
-           initial={{ scale: 0 }}
-           animate={{ scale: [0, 2, 0] }}
-           transition={{ duration: 0.6, ease: "easeOut" }}
-         >
-           <div className="w-16 h-16 rounded-full bg-gradient-radial from-yellow-300/50 via-pink-400/30 to-transparent animate-ping" />
-         </motion.div>
-       )}
+               ))}
+             </>
+           )}
+         </AnimatePresence>
+       </div>
      </>
    )
  }
+ 
+ export default CustomCursor
```

---

## 2. Implement Redis Caching Strategy

Now let's update the Redis cache service to include better error handling and performance optimizations:

---

```diff
    lazyConnect?: boolean
    cluster?: string[]
+   enableCircuitBreaker?: boolean
+   circuitBreakerThreshold?: number
+   circuitBreakerTimeout?: number
  }
  
```

```diff
    errors: number
    averageLatency: number
+   circuitBreakerState: 'closed' | 'open' | 'half-open'
+   connectionState: 'connected' | 'disconnected' | 'connecting'
+ }
+ 
+ interface CircuitBreakerState {
+   failureCount: number
+   lastFailureTime: number
+   state: 'closed' | 'open' | 'half-open'
+   threshold: number
+   timeout: number
  }
  
```

```diff
      deletes: 0,
      errors: 0,
-     averageLatency: 0
+     averageLatency: 0,
+     circuitBreakerState: 'closed',
+     connectionState: 'disconnected'
    }
    private latencyTracker: number[] = []
+   private circuitBreaker: CircuitBreakerState
  
    constructor(config: RedisCacheConfig = {}) {
```

```diff
        enableReadyCheck: config.enableReadyCheck ?? true,
        lazyConnect: config.lazyConnect ?? true,
-       cluster: config.cluster
+       cluster: config.cluster,
+       enableCircuitBreaker: config.enableCircuitBreaker ?? true,
+       circuitBreakerThreshold: config.circuitBreakerThreshold || 5,
+       circuitBreakerTimeout: config.circuitBreakerTimeout || 60000
+     }
+ 
+     // Initialize circuit breaker
+     this.circuitBreaker = {
+       failureCount: 0,
+       lastFailureTime: 0,
+       state: 'closed',
+       threshold: this.config.circuitBreakerThreshold!,
+       timeout: this.config.circuitBreakerTimeout!
      }
  
```

```diff
  
    private async initializeRedis(): Promise<void> {
+     this.metrics.connectionState = 'connecting'
+     
      try {
        if (this.config.cluster && this.config.cluster.length > 0) {
```

```diff
            retryDelayOnFailover: this.config.retryDelayOnFailover,
            enableReadyCheck: this.config.enableReadyCheck,
-           lazyConnect: this.config.lazyConnect
+           lazyConnect: this.config.lazyConnect,
+           keepAlive: 30000,
+           connectTimeout: 10000,
+           commandTimeout: 5000
          })
        }
```

```diff
          console.log('✅ Redis connected successfully')
          this.isConnected = true
+         this.metrics.connectionState = 'connected'
+         this.resetCircuitBreaker()
        })
  
        this.redis.on('error', (error) => {
          console.error('❌ Redis connection error:', error)
-         this.metrics.errors++
-         this.isConnected = false
+         this.handleConnectionError(error)
        })
  
        this.redis.on('ready', () => {
          console.log('🚀 Redis ready for operations')
          this.isConnected = true
+         this.metrics.connectionState = 'connected'
+         this.resetCircuitBreaker()
        })
  
        this.redis.on('reconnecting', () => {
          console.log('🔄 Redis reconnecting...')
          this.isConnected = false
+         this.metrics.connectionState = 'connecting'
+       })
+ 
+       this.redis.on('close', () => {
+         console.log('🔌 Redis connection closed')
+         this.isConnected = false
+         this.metrics.connectionState = 'disconnected'
        })
  
      } catch (error) {
        console.error('Failed to initialize Redis:', error)
-       this.metrics.errors++
+       this.handleConnectionError(error)
+     }
+   }
+ 
+   private handleConnectionError(error: any): void {
+     this.metrics.errors++
+     this.isConnected = false
+     this.metrics.connectionState = 'disconnected'
+     
+     if (this.config.enableCircuitBreaker) {
+       this.updateCircuitBreaker(false)
+     }
+   }
+ 
+   private updateCircuitBreaker(success: boolean): void {
+     const now = Date.now()
+     
+     if (success) {
+       if (this.circuitBreaker.state === 'half-open') {
+         this.resetCircuitBreaker()
+       }
+     } else {
+       this.circuitBreaker.failureCount++
+       this.circuitBreaker.lastFailureTime = now
+       
+       if (this.circuitBreaker.failureCount >= this.circuitBreaker.threshold) {
+         this.circuitBreaker.state = 'open'
+         this.metrics.circuitBreakerState = 'open'
+         console.warn(`🚨 Redis circuit breaker opened after ${this.circuitBreaker.failureCount} failures`)
+       }
+     }
+   }
+ 
+   private resetCircuitBreaker(): void {
+     this.circuitBreaker.failureCount = 0
+     this.circuitBreaker.state = 'closed'
+     this.metrics.circuitBreakerState = 'closed'
+   }
+ 
+   private canExecuteRedisOperation(): boolean {
+     if (!this.config.enableCircuitBreaker) return true
+     
+     const now = Date.now()
+     
+     switch (this.circuitBreaker.state) {
+       case 'closed':
+         return true
+       case 'open':
+         if (now - this.circuitBreaker.lastFailureTime > this.circuitBreaker.timeout) {
+           this.circuitBreaker.state = 'half-open'
+           this.metrics.circuitBreakerState = 'half-open'
+           return true
+         }
+         return false
+       case 'half-open':
+         return true
+       default:
+         return false
      }
    }
```

```diff
      
      try {
-       // Try Redis first if connected
-       if (this.redis && this.isConnected) {
+       // Check circuit breaker before Redis operation
+       if (this.redis && this.isConnected && this.canExecuteRedisOperation()) {
          const cached = await this.redis.get(key)
          this.trackLatency(startTime)
+         this.updateCircuitBreaker(true)
          
          if (cached) {
```

```diff
        console.error('Redis get error:', error)
        this.metrics.errors++
+       this.updateCircuitBreaker(false)
        
        // Fallback to memory cache
```

```diff
        }
        
-       // Set in Redis if connected
-       if (this.redis && this.isConnected) {
+       // Set in Redis if connected and circuit breaker allows
+       if (this.redis && this.isConnected && this.canExecuteRedisOperation()) {
          await this.redis.setex(key, effectiveTTL, JSON.stringify(data))
          this.trackLatency(startTime)
+         this.updateCircuitBreaker(true)
+         this.metrics.sets++
        }
        
        // Also set in memory cache as backup
        await super.set(key, value, ttl)
-       this.metrics.sets++
        
      } catch (error) {
        console.error('Redis set error:', error)
        this.metrics.errors++
+       this.updateCircuitBreaker(false)
        
        // Fallback to memory cache only
```

```diff
        deletes: 0,
        errors: 0,
-       averageLatency: 0
+       averageLatency: 0,
+       circuitBreakerState: 'closed',
+       connectionState: 'disconnected'
      }
      this.latencyTracker = []
```

---



---

## 3. Add API Route Authentication Middleware

Let's create a comprehensive middleware system for protecting API routes:

---

```diff
  /**
-  * Authentication middleware for API routes
+  * Enhanced authentication middleware for API routes
   * 
   * @module api/auth-middleware
```

```diff
  import { getCurrentUser } from '@/lib/firebase/auth-session-server'
  import { createAuthError, withErrorHandler } from './error-handler'
+ import { RateLimiters, withRateLimit } from './rate-limit-middleware'
  
  /**
```

```diff
      emailVerified?: boolean
      customClaims?: Record<string, any>
+     sessionDuration?: number
+     lastLogin?: Date
  }
  
```

```diff
  export interface AuthenticatedContext {
      user: AuthenticatedUser
+     requestId?: string
+     timestamp: number
+     userAgent?: string
+     ipAddress?: string
      [key: string]: any
  }
```

```diff
  
  /**
-  * Authentication middleware that verifies user session
-  * and provides user context to handlers
+  * Security configuration for auth middleware
+  */
+ interface SecurityConfig {
+     requireEmailVerification?: boolean
+     maxSessionAge?: number // in milliseconds
+     allowedOrigins?: string[]
+     logRequests?: boolean
+     enforceHttps?: boolean
+     checkUserAgent?: boolean
+ }
+ 
+ /**
+  * Enhanced authentication middleware with comprehensive security features
   * 
   * @param handler - The API route handler that requires authentication
+  * @param config - Security configuration options
   * @returns Wrapped handler with authentication protection
   * 
```

```diff
   *   const userData = await getUserData(user.uid)
   *   return successResponse(userData)
+  * }, {
+  *   requireEmailVerification: true,
+  *   maxSessionAge: 24 * 60 * 60 * 1000, // 24 hours
+  *   logRequests: true
   * })
   * ```
   */
- export function withAuth(handler: AuthenticatedHandler) {
-     return withErrorHandler(async (request: NextRequest, context: any = {}) => {
+ export function withAuth(handler: AuthenticatedHandler, config: SecurityConfig = {}) {
+     const {
+         requireEmailVerification = false,
+         maxSessionAge = 7 * 24 * 60 * 60 * 1000, // 7 days default
+         allowedOrigins = [],
+         logRequests = process.env.NODE_ENV === 'development',
+         enforceHttps = process.env.NODE_ENV === 'production',
+         checkUserAgent = true
+     } = config
+ 
+     return withRateLimit(RateLimiters.api)(withErrorHandler(async (request: NextRequest, context: any = {}) => {
+         const requestId = crypto.randomUUID()
+         const timestamp = Date.now()
+         const userAgent = request.headers.get('user-agent')
+         const ipAddress = getClientIP(request)
+ 
+         // Security checks
+         if (enforceHttps && !request.url.startsWith('https://')) {
+             throw createAuthError('HTTPS required for secure authentication')
+         }
+ 
+         // Origin validation for CORS
+         if (allowedOrigins.length > 0) {
+             const origin = request.headers.get('origin')
+             if (origin && !allowedOrigins.includes(origin)) {
+                 throw createAuthError('Origin not allowed')
+             }
+         }
+ 
+         // Suspicious user agent check
+         if (checkUserAgent && (!userAgent || isSuspiciousUserAgent(userAgent))) {
+             if (logRequests) {
+                 console.warn(`⚠️ Suspicious user agent detected: ${userAgent} from IP: ${ipAddress}`)
+             }
+         }
+ 
          // Get current user from session
          const user = await getCurrentUser()
          
          // Check if user is authenticated
          if (!user?.uid) {
+             if (logRequests) {
+                 console.warn(`🚫 Unauthorized access attempt from IP: ${ipAddress}`)
+             }
              throw createAuthError('Authentication required')
          }
```

```diff
              throw createAuthError('Invalid session')
          }
+ 
+         // Email verification check
+         if (requireEmailVerification && !user.emailVerified) {
+             throw createAuthError('Email verification required')
+         }
+ 
+         // Session age validation
+         const sessionAge = Date.now() - (user.lastLogin?.getTime() || 0)
+         if (maxSessionAge > 0 && sessionAge > maxSessionAge) {
+             throw createAuthError('Session expired, please log in again')
+         }
  
          // Create authenticated context
```

```diff
                  displayName: user.displayName,
                  emailVerified: user.emailVerified,
-                 customClaims: user.customClaims
-             }
+                 customClaims: user.customClaims,
+                 sessionDuration: sessionAge,
+                 lastLogin: user.lastLogin
+             },
+             requestId,
+             timestamp,
+             userAgent,
+             ipAddress
+         }
+ 
+         // Request logging
+         if (logRequests) {
+             console.log(`🔐 Authenticated request: ${request.method} ${request.url} - User: ${user.uid} - IP: ${ipAddress}`)
          }
  
          // Call the handler with authenticated context
-         return await handler(request, authenticatedContext)
-     })
+         const response = await handler(request, authenticatedContext)
+ 
+         // Add security headers
+         response.headers.set('X-Request-ID', requestId)
+         response.headers.set('X-Frame-Options', 'DENY')
+         response.headers.set('X-Content-Type-Options', 'nosniff')
+         response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin')
+ 
+         return response
+     }))
  }
  
```

```diff
   * 
   * @param handler - The API route handler
+  * @param config - Security configuration options
   * @returns Wrapped handler with optional user context
   * 
```

```diff
   */
  export function withOptionalAuth(
-     handler: (request: NextRequest, context: { user?: AuthenticatedUser }) => Promise<NextResponse>
+     handler: (request: NextRequest, context: { user?: AuthenticatedUser; requestId: string; timestamp: number }) => Promise<NextResponse>,
+     config: SecurityConfig = {}
  ) {
-     return withErrorHandler(async (request: NextRequest, context: any = {}) => {
+     const { logRequests = process.env.NODE_ENV === 'development' } = config
+ 
+     return withRateLimit(RateLimiters.publicData)(withErrorHandler(async (request: NextRequest, context: any = {}) => {
+         const requestId = crypto.randomUUID()
+         const timestamp = Date.now()
+ 
          try {
              const user = await getCurrentUser()
```

```diff
                      displayName: user.displayName,
                      emailVerified: user.emailVerified,
-                     customClaims: user.customClaims
-                 } : undefined
-             }
- 
-             return await handler(request, extendedContext)
+                     customClaims: user.customClaims,
+                     lastLogin: user.lastLogin
+                 } : undefined,
+                 requestId,
+                 timestamp
+             }
+ 
+             if (logRequests) {
+                 console.log(`📊 Public request: ${request.method} ${request.url} - User: ${user?.uid || 'anonymous'}`)
+             }
+ 
+             const response = await handler(request, extendedContext)
+             response.headers.set('X-Request-ID', requestId)
+             return response
          } catch (error) {
              // If authentication fails, continue without user context
-             return await handler(request, { ...context, user: undefined })
+             const response = await handler(request, { ...context, user: undefined, requestId, timestamp })
+             response.headers.set('X-Request-ID', requestId)
+             return response
          }
-     })
+     }))
  }
  
  /**
-  * Role-based authentication middleware
+  * Role-based authentication middleware with enhanced security
   * 
   * @param requiredRoles - Array of roles required to access the endpoint
   * @param handler - The API route handler
+  * @param config - Security configuration options
   * @returns Wrapped handler with role-based protection
   * 
```

```diff
   *   // User is guaranteed to have admin or moderator role
   *   return getAdminData()
+  * }, {
+  *   requireEmailVerification: true,
+  *   logRequests: true
   * })
   * ```
   */
- export function withRoles(requiredRoles: string[], handler: AuthenticatedHandler) {
+ export function withRoles(requiredRoles: string[], handler: AuthenticatedHandler, config: SecurityConfig = {}) {
      return withAuth(async (request: NextRequest, context: AuthenticatedContext) => {
          const userRoles = context.user.customClaims?.roles || []
```

```diff
          
          if (!hasRequiredRole) {
+             console.warn(`🚨 Access denied for user ${context.user.uid}: Required roles: ${requiredRoles.join(', ')}, User roles: ${userRoles.join(', ')}`)
              throw createAuthError('Insufficient permissions')
          }
  
+         console.log(`✅ Role check passed for user ${context.user.uid}: ${userRoles.join(', ')}`)
          return await handler(request, context)
-     })
+     }, config)
  }
  
```

```diff
   * 
   * @param handler - The API route handler
+  * @param config - Security configuration options
   * @returns Wrapped handler that requires email verification
   * 
```

```diff
   * ```
   */
- export function withEmailVerification(handler: AuthenticatedHandler) {
+ export function withEmailVerification(handler: AuthenticatedHandler, config: SecurityConfig = {}) {
      return withAuth(async (request: NextRequest, context: AuthenticatedContext) => {
          if (!context.user.emailVerified) {
```

```diff
  
          return await handler(request, context)
-     })
+     }, { ...config, requireEmailVerification: true })
  }
  
```

```diff
   * 
   * @param handler - The API route handler
+  * @param config - Security configuration options
   * @returns Wrapped handler that requires admin role
   */
- export function withAdminAuth(handler: AuthenticatedHandler) {
-     return withRoles(['admin'], handler)
+ export function withAdminAuth(handler: AuthenticatedHandler, config: SecurityConfig = {}) {
+     return withRoles(['admin'], handler, config)
  }
  
```

```diff
   * 
   * @param handler - The API route handler
+  * @param config - Security configuration options
   * @returns Wrapped handler that requires moderator or admin role
   */
- export function withModeratorAuth(handler: AuthenticatedHandler) {
-     return withRoles(['admin', 'moderator'], handler)
+ export function withModeratorAuth(handler: AuthenticatedHandler, config: SecurityConfig = {}) {
+     return withRoles(['admin', 'moderator'], handler, config)
+ }
+ 
+ /**
+  * Combined authentication and rate limiting for sensitive operations
+  * 
+  * @param handler - The API route handler
+  * @param config - Security configuration options
+  * @returns Wrapped handler with strict security
+  */
+ export function withStrictAuth(handler: AuthenticatedHandler, config: SecurityConfig = {}) {
+     return withRateLimit(RateLimiters.auth)(withAuth(handler, {
+         requireEmailVerification: true,
+         enforceHttps: true,
+         logRequests: true,
+         checkUserAgent: true,
+         ...config
+     }))
+ }
+ 
+ /**
+  * Utility functions for security checks
+  */
+ 
+ function getClientIP(request: NextRequest): string {
+     const forwarded = request.headers.get('x-forwarded-for')
+     const realIP = request.headers.get('x-real-ip')
+     const cloudflareIP = request.headers.get('cf-connecting-ip')
+     
+     return cloudflareIP || realIP || (forwarded ? forwarded.split(',')[0].trim() : 'unknown')
+ }
+ 
+ function isSuspiciousUserAgent(userAgent: string): boolean {
+     const suspiciousPatterns = [
+         /bot/i,
+         /crawler/i,
+         /spider/i,
+         /scraper/i,
+         /curl/i,
+         /wget/i,
+         /python/i,
+         /java/i,
+         /go-http-client/i,
+         /^$/,
+         /^-$/
+     ]
+     
+     return suspiciousPatterns.some(pattern => pattern.test(userAgent))
+ }
+ 
+ /**
+  * Create middleware factory for custom authentication requirements
+  * 
+  * @param requirements - Custom authentication requirements
+  * @returns Middleware factory function
+  */
+ export function createAuthMiddleware(requirements: {
+     roles?: string[]
+     emailVerified?: boolean
+     maxSessionAge?: number
+     rateLimit?: 'strict' | 'moderate' | 'lenient'
+     customValidator?: (user: AuthenticatedUser) => Promise<boolean>
+ }) {
+     return function(handler: AuthenticatedHandler, config: SecurityConfig = {}) {
+         let middleware = withAuth
+ 
+         // Apply rate limiting based on requirement
+         if (requirements.rateLimit === 'strict') {
+             middleware = (h: AuthenticatedHandler, c: SecurityConfig) => withRateLimit(RateLimiters.auth)(withAuth(h, c))
+         } else if (requirements.rateLimit === 'moderate') {
+             middleware = (h: AuthenticatedHandler, c: SecurityConfig) => withRateLimit(RateLimiters.search)(withAuth(h, c))
+         }
+ 
+         // Apply role-based protection if needed
+         if (requirements.roles && requirements.roles.length > 0) {
+             return withRoles(requirements.roles, handler, {
+                 requireEmailVerification: requirements.emailVerified,
+                 maxSessionAge: requirements.maxSessionAge,
+                 ...config
+             })
+         }
+ 
+         // Apply custom validation if provided
+         if (requirements.customValidator) {
+             return middleware(async (request: NextRequest, context: AuthenticatedContext) => {
+                 const isValid = await requirements.customValidator!(context.user)
+                 if (!isValid) {
+                     throw createAuthError('Custom validation failed')
+                 }
+                 return await handler(request, context)
+             }, {
+                 requireEmailVerification: requirements.emailVerified,
+                 maxSessionAge: requirements.maxSessionAge,
+                 ...config
+             })
+         }
+ 
+         return middleware(handler, {
+             requireEmailVerification: requirements.emailVerified,
+             maxSessionAge: requirements.maxSessionAge,
+             ...config
+         })
+     }
  }
```

---



---

## 4. Optimize Header Component Performance

Now let's optimize the Header component by reducing unnecessary re-renders and improving performance:

---



---

